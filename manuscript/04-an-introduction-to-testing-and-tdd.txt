# An Introduction to Testing and TDD

Here's I'm going to quickly cover some of the testing tools we will be using
and give a brief introduction to TDD. This is an optional chapter so if you are
familiar with these tools and TDD feel free to skip it. However, if you are new
to it or feel you would like to understand it better then it's worth a read.

Like most of the things I've covered so far, this chapter is just here to serve
as a brief introduction to give you what you will need to work through the rest
of this book. As always I recommend you research further with all the wonderful
resources out there.

## Types of Test

The 2 main types of testing I will be using the process of building our
application are *acceptance tests* and *unit tests*.

### Acceptance Tests {#acceptance-tests}

*Acceptance tests* are high level tests which confirm to the customer that the
features they've asked for are implemented and are working properly. Since
these tests are about producing the feature that the customer requests, they
are ideally produced with the customer's presence and input, in a form which
they can understand.

A typical example might be to write something down like:

> #### Listing customers when there are none will return an empty list
>
> Given there are no customers
>
> When I ask to list customers
>
> Then I should get an empty list

These could then be simply implemented in any assert based test framework like
so:

{title="xUnit style acceptance test example:", lang="php"}
~~~~~~~~
function test_listing_customers_where_there_a_none_will_return_an_empty_list()
{
    // Given there are no customers
    $customerRepository = new CustomerRepository();
    $customerRepository->removeAll();

    // When I ask to list customers
    $lister = new CustomerLister($customerRepository);
    $customers = $lister->listCustomers();

    // Then I should get an empty list
    $this->assertEquals([], $customers);
}
~~~~~~~~

This works, the comments are there to explain the test in terms the customer can
understand and the code checks the conditions are met. That said it does mix up
the 2 customers language with the programmers and it relies on comments being
present and correct. Therefore, if you are working the customer on producing
acceptance tests then there is a better tool for the job, it's called
*cucumber* and it PHP it's implemented by a tool called
[Behat](http://behat.org/).

*Cucumber* scripts are tests written in a language that the customer can read
and write and are grouped as *features*. They look very much like the original
test rules we started with:

{title="Behat acceptance test example", lang="cucumber"}
~~~~~~~~
Feature: List customers
    In order to view a list of customers on the system
    As an administrator
    I need to be able to see lists of the customers information

    Scenario: Listing customers when there are none will return an empty list
        Given there are no customers
        When I ask to list customers
        Then I should get an empty list
~~~~~~~~

The language which is used in the Behat features can include any phrases that
you want to include. The meanings of these phases (called *snippets*) are then
implemented in PHP in *context* classes like so:

{title="Behat context example", lang="php"}
~~~~~~~~
<?php

use Behat\Behat\Tester\Exception\PendingException;
use Behat\Behat\Context\SnippetAcceptingContext;
use Behat\Gherkin\Node\PyStringNode;
use Behat\Gherkin\Node\TableNode;

/**
 * Behat context class.
 */
class FeatureContext implements SnippetAcceptingContext
{
    /**
     * @var CustomerRepository
     */
    private $customerRepository;

    /**
     * @var mixed
     */
    private $result;

    /**
     * Initializes context.
     *
     * Every scenario gets its own context object.
     * You can also pass arbitrary arguments to the context constructor through
     * behat.yml.
     */
    public function __construct()
    {
        $this->customerRepository = new CustomerRepository();
    }

    /**
     * @Given there are no customers
     */
    public function thereAreNoCustomers()
    {
        $this->customerRepository->removeAll();
    }

    /**
     * @When I ask to list customers
     */
    public function iAskToListCustomers()
    {
        $lister = new CustomerLister($this->customerRepository);
        $this->result = $lister->listCustomers();
    }

    /**
     * @Then I should get an empty list
     */
    public function iShouldGetAnEmptyList()
    {
        if ([] !== $this->result) {
            throw new Exception('Result was not an empty array.');
        }
    }
}
~~~~~~~~

The different *snippets* can then reused in other *scenarios* and *features*.

In this I will be providing the *features* for each new bit of functionality
that we add and well use Behat to test them.

### Unit Tests

*Unit tests* are for the development teams benefit, they are not written with
the customer's help, in fact the customer may not even know they exist.
Instead, they are create by the developer as the code is written to test little
bits of code as isolated *units*. A unit is a small piece of code which
performs a specific task, often we treat each class as a unit but in reality a
multiple classes or a subsection of a class could be considered a unit. Saying
that PHPSpec, the main tool we will be using for unit testing, does treat each
individual class as a *unit*.

When doing [TDD](#tdd) the tests are actually written before each new bit of 
code is written. This process when used properly actually influences what code
is written, sometimes producing surprisingly elegant solutions.

There are 2 main types of *unit testing* tools, these are *xUnit* style tools
and *BDD* style tools.

#### xUnit Frameworks

*xUnit* test tools are call so because each language has a least one of these
tools available and they are generally named *SomethingUnit* (e.g. JUnit for
Java, CppUnit for C++). The origin of these names comes from *Smalltalk's*
*SUnit* which was created by Kent Beck and was the first testing framework of
this kind. Of course, PHP has such a framework and as expected it is called
*PHPUnit*. *PHPUnit* is probably PHP's most well used unit testing framework
and was created by Sebastian Bergmann.

*xUnit* frameworks are based on assertions, each framework provides a set of
available assertion functions, these are used to check the results our code
produces are what we expect. Some examples of the assertions functions
available in *PHPUnit* are:

{title="PHPUnit assertions example", lang="php"}
~~~~~~~~
$this->assertEquals(7, $subject->getValue());
$this->assertSame($expectedOwner, $subject->getOwner());
$this->assertFalse($subject->isBroken());
$this->assertTrue($subject->isWonderful());
$this->assertNull($subject->getNothing());
// ...
~~~~~~~~

A full list of *PHPUnit's* assertions can be found in [Appendix
A](https://phpunit.de/manual/current/en/appendixes.assertions.html) of the
manual.

While I will not be using PHPUnit as the main *unit testing* framework in this
book we will be making use of it at some point for certain tests. We will
also make use if its assertion library in our *Behat Contexts* for simplicity.

#### BDD Frameworks

The second type of unit testing frameworks are [BDD](#bdd) *spec* frameworks.
These are used in a very similar way to *xUnit* frameworks but the language
used in a bit different. Instead of *asserting* a conditions expectations are
described using the work *should*. I will be using
[PHPSpec](http://www.phpspec.net/) which is a great but *highly opinionated*
BDD unit testing tool for PHP.

Using PHPSpec the assertions we looked at for PHPUnit would written like this
instead:

{title="PHPSpec tests example", lang="php"}
~~~~~~~~
$this->getValue()->shouldReturn(7);
$this->getOwner()->shouldReturn($expectedOwner);
$this->shouldNotBeBroken();
$this->shouldBeWonderful();
$this->getNothing()->shouldReturn(null);
~~~~~~~~

The first difference you should notice is that they just read as better
sentences than the *PHPUnit* assertions.

There is a second difference though: assertions allow you to assert the values
of anything whereas, PHPSpec's _should\*_ methods only work on return values
from the unit being tested or on test doubles. This means that you are much
more limited in how you can test with *PHPSpec* but this is not necessarily a
bad thing, it forces you to write good code and I like this (it's not for
everyone though).

#### Red, Green, Refactor: The TDD Unit Testing Process

When doing [TDD](#tdd) there is a process to the order in which things should
be done. This order is known as **Red, Green, Refactor**:

Red

: Red means that when we run our test suite we see a failing test. This is the
first step in writing code: *write a failing test*. The test we write should be
next smallest step we can take in our implementation that will cause the test
suite to fail. Once the test is written you must run the test suite and you
**must see it fail**.

Green

: The green step is making the failing test pass. In order to do this you only
write **the smallest amount of code needed to make the failing test pass**.
Then we run the test suite again and see that all tests pass.

Refactor

: The refactor step is the point at which the code can and should be
refactored.  No functionality should be altered here, you simply tidy up the
code. After any refactorings have been made you must run the test suite to make
sure you've not broken anything.

After the *Refactor* step you go back to the **Red** step and write the next 
failing test. This process is repeated until the solution is complete.

![The Red, Green, Refactor Cycle](images/04-red-green-refactor.png)

I will run though a demonstration of this process shortly in the [Unit Testing
With PHPSpec](#unit-testing-with-phpspec) section.

## Given, When, Then

We've already seen the use of these 3 words earlier in the [Acceptance
Tests](#acceptance-tests) section. However, these 3 steps apply to all types
of tests. The *given* part sets up the preconditions, the *when* part performs
the action being tested and the *then* part checks the result. Whenever you
are writing a test it is a good idea to maintain clear grouping into these 3
stages.

We've seen this in Behat already, it's highlighted and enforce by the *Cucumber*
language. Now lets take a look an example in a *PHPUnit* & a *PHPSpec* test:

{title="Given, When, Then example using PHPUnit", lang="php"}
~~~~~~~~
// Inside AgeCalcuatorTest
function test_calculate_the_age_of_a_customer()
{
    // Given there is a customer who's date of birth is 1982-03-15
    // And today is 2014-09-03
    $customer = new Customer('customer name', Date::fromDate('1982-03-15'));
    $today = Date::fromDate('2014-09-03');

    // When I calcuate the age of the customer
    $calculator = new AgeCalculator($today);
    $age = $calculator->calculateAge($customer);

    // Then the result should be 32
    $this->assertEquals(32, $age);
}
~~~~~~~~

{title="Given, When, Then example using PHPSpec", lang="php"}
~~~~~~~~
// Inside AgeCalcuatorSpec
function it_can_calculate_the_age_of_a_customer()
{
    // Given there is a customer who's date of birth is 1982-03-15
    // And today is 2014-09-03
    $customer = new Customer('customer name', Date::fromDate('1982-03-15'));
    $this->beConstructedWith(Date::fromDate('2014-09-03'));

    // When I calcuate the age of the customer
    $age = $calculator->calculateAge($customer);

    // Then the result should be 32
    $age->shouldBe(32);
}
~~~~~~~~

The comments are not actually necessary and it's also find to compound the
various expressions (particularly the *when* and *then*) but the point is not
to mix up the orders of each stage. I also like to use vertical whitespace to 
separate the setting up of the preconditions from the tests. A more condensed
version of the *PHPSpec* example would be:

{title="Condensed Given, When, Then example using PHPSpec", lang="php"}
~~~~~~~~
// Inside AgeCalcuatorSpec
function it_can_calculate_the_age_of_a_customer()
{
    $customer = new Customer('customer name', Date::fromDate('1982-03-15'));
    $this->beConstructedWith(Date::fromDate('2014-09-03'));

    $calculator->calculateAge($customer)->shouldReturn(32);
}
~~~~~~~~

I think that looks pretty neat and is very easy to read and understand what is
supposed to happen.

## Acceptance Testing with Behat

We've already seen *Behat* and seen what *Cucumber* tests look like so lets
have a go at setting up a project using them. To start off create a new folder
for the project and `cd` into it:

```
$ mkdir behat-example
$ cd behat-example
```

Next up let's add Behat to the project. We've already seen how to set up the
`composer.json` file but there is a simpler way; we can create it, add 
the `composer.json`, add Behat to it and run `composer update` all in one
command like so:

```
$ composer require behat/behat:3.* --dev
```

Once it has run let Behat will be installed in the project and the `behat`
command is not available to us. Now we need to tell Behat to initialise the project,
to do this simple run:

```
$ behat --init
```

This command creates a directory called `features`, these is where we'll put
the tests. It also creates directory called `features/bootstrap` which contains
a file called `FeatureContext.php`, this is the default context where we can
add our *snippets*.

Now let's add a feature by create a file called `features/list-books.feature`:

{title="features/list-books.feature", lang="cucumber"}
~~~~~~~~
Feature: List books
    In order to list books
    As a reader
    I must be able to view a list of all books stored on the system

    Scenario: Display an empty list
        Given there are no books
        When I list all books
        Then I should see an empty list
~~~~~~~~

Next run Behat:

```
$ behat
```

And you should see this:

```
Feature: List books
    In order to list books
    As a reader
    I must be able to view a list of all books stored on the system

  Scenario: Display an empty list   # features/list-books.feature:6
    Given there are no books
    When I list all books
    Then I should see an empty list

1 scenario (1 undefined)
3 steps (3 undefined)
0m0.03s (9.00Mb)

--- FeatureContext has missing steps. Define them with these snippets:

    /**
     * @Given there are no books
     */
    public function thereAreNoBooks()
    {
        throw new PendingException();
    }

    /**
     * @When I list all books
     */
    public function iListAllBooks()
    {
        throw new PendingException();
    }

    /**
     * @Then I should see an empty list
     */
    public function iShouldSeeAnEmptyList()
    {
        throw new PendingException();
    }
```

This is Behat saying that I doesn't understand the *snippets* which we have
used in the test. It also gives some template code which can be copied and
pasted into our feature context to implement these *snippets*, We could do that
but we can actually get Behat to do this for use by running:

```
$ behat --append-snippets
```

After this command is run if you look in `features/bootstrap/FeatureContext.php`
you will see the template code has been added for the 3 *snippets*. At this point
if we run Behat again:

```
$ behat
```

It informs use that the first *snippet* has needs to be implemented (the others
have been skipped). Let's do this now.

Inside `features/bootstrap/FeatureContext.php` update it to look like this:

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
<?php

use Behat\Behat\Tester\Exception\PendingException;
use Behat\Behat\Context\SnippetAcceptingContext;
use Behat\Gherkin\Node\PyStringNode;
use Behat\Gherkin\Node\TableNode;

use BehatExample\BookList;

/**
 * Behat context class.
 */
class FeatureContext implements SnippetAcceptingContext
{
    /**
     * @var BookList
     */
    private $bookList;

    /**
     * Initializes context.
     *
     * Every scenario gets its own context object.
     * You can also pass arbitrary arguments to the context constructor through
     * behat.yml.
     */
    public function __construct()
    {
        $this->bookList = new BookList();
    }

    /**
     * @Given there are no books
     */
    public function thereAreNoBooks()
    {
        $this->bookList->clear();
    }

    /**
     * @When I list all books
     */
    public function iListAllBooks()
    {
        throw new PendingException();
    }

    /**
     * @Then I should see an empty list
     */
    public function iShouldSeeAnEmptyList()
    {
        throw new PendingException();
    }
}
~~~~~~~~

You can try running Behat again now but it will fail since there is no
`BookList` class. To create this quickly set up the autoloader by updating the 
`composer.json` to look like this:

<<[composer.json](examples/chapter-04/behat-example/composer.json)

Then create the directory for the source code and update Composer:

```
$ mkdir -p src/BehatExample
$ composer update
```

Now we can create the `BookList` class:

{title="src/BehatExample/BookList.php", lang="php"}
~~~~~~~~
<?php

namespace BehatExample;

class BookList
{
    public function clear()
    {
    }
}

Running Behat now will show the first *snippet* passing and inform that the
second snippet needs to up implemented. Let's implement the last 2 *snippets*
together, update the `features/bootstrap/FeatureContext.php` to contain the
following:

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
<?php

use Behat\Behat\Tester\Exception\PendingException;
use Behat\Behat\Context\SnippetAcceptingContext;
use Behat\Gherkin\Node\PyStringNode;
use Behat\Gherkin\Node\TableNode;

use BehatExample\BookList;

/**
 * Behat context class.
 */
class FeatureContext implements SnippetAcceptingContext
{
    /** @var BookList */
    private $bookList;

    /** @var mixed */
    private $result;

    /**
     * Initializes context.
     *
     * Every scenario gets its own context object.
     * You can also pass arbitrary arguments to the context constructor through
     * behat.yml.
     */
    public function __construct()
    {
        $this->bookList = new BookList();
    }

    /**
     * @Given there are no books
     */
    public function thereAreNoBooks()
    {
        $this->bookList->clear();
    }

    /**
     * @When I list all books
     */
    public function iListAllBooks()
    {
        $this->result = $this->bookList->getBooks();
    }

    /**
     * @Then I should see an empty list
     */
    public function iShouldSeeAnEmptyList()
    {
        if ([] !== $this->result) {
            throw new Exception('Result was incorrect.');
        }
    }
}
~~~~~~~~

Again we've not implemented `BookList::getBooks()` so lets quickly do that now:

{title="src/BehatExample/BookList.php", lang="php"}
~~~~~~~~
<?php

namespace BehatExample;

class BookList
{
    public function clear()
    {
    }

    /** @return array */
    public function getBooks()
    {
        return [];
    }
}
~~~~~~~~

Now run Behat:

```
$ behat
```

And you will see the test pass:

```
Feature: List books
    In order to list books
    As a reader
    I must be able to view a list of all books stored on the system

  Scenario: Display an empty list
    Given there are no books
    When I list all books
    Then I should see an empty list

1 scenario (1 passed)
3 steps (3 passed)
0m0.01s (9.10Mb)
```

Finally let's quickly add another test to the feature by appending the
following to `features/list-books.feature`:

{title="features/list-books.feature", lang="cucumber"}
~~~~~~~~

    Scenario: Books are listed in alphabetical order
        Given there is a book called "Domain Driven Design" by "Eric Evans"
        And there is a book called "Refactoring" by "Martin Fowler"
        And there is a book called "Design Patterns" by "The Gang of Four"
        When I list all books
        Then I should see:
            | title                | author           |
            | Design Patterns      | The Gang of Four |
            | Domain Driven Design | Eric Evans       |
            | Refactoring          | Martin Fowler    |
~~~~~~~~

Again, if you run Behat it will say that there are new, unknown *snippets*. As
before add these by running:

```
$ behat --append-snippets
```

Open up `features/bootstrap/FeatureContext.php` again and update the 2 appended
methods to look like this:

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~

    /**
     * @Given there is a book called :title by :author
     */
    public function thereIsABookCalledBy($title, $author)
    {
        $this->bookList->add($title, $author);
    }

    /**
     * @Then I should see:
     */
    public function iShouldSee(TableNode $table)
    {
        if ($table->getHash() !== $this->result) {
            throw new Exception('Result was incorrect.');
        }
    }
~~~~~~~~

Finally update `BehatExample\BookList` to contain a working implementation:

<<[src/BehatExample/BookList.php](examples/chapter-04/behat-example/src/BehatExample/BookList.php)

Now run Behat to see the tests pass:

```
$ behat
```

The result:

```
Feature: List books
    In order to list books
    As a reader
    I must be able to view a list of all books stored on the system

  Scenario: Display an empty list
    Given there are no books
    When I list all books
    Then I should see an empty list

  Scenario: Books are listed in alphabetical order
    Given there is a book called "Domain Driven Design" by "Eric Evans" 
    And there is a book called "Refactoring" by "Martin Fowler"
    And there is a book called "Design Patterns" by "The Gang of Four" 
    When I list all books                                               
    Then I should see:                                                  
      | title                | author           |
      | Design Patterns      | The Gang of Four |
      | Domain Driven Design | Eric Evans       |
      | Refactoring          | Martin Fowler    |

2 scenarios (2 passed)
8 steps (8 passed)
0m0.02s (9.15Mb)
```

# Mink & Selenium

### The Mink Context

### Which Language to use in Interface Tests

## Unit Testing with PHPSpec {#unit-testing-with-phpspec}

## Test Doubles

### Testing Dependencies Which Don't Exist Yet

## The Double Feedback Loop

## Resources
