# An Introduction to Testing and TDD

Here I'm going to quickly cover some testing tools which we will be using as
well as give a brief introduction to TDD. This is an optional chapter so if you
are already familiar with these tools and TDD feel free to skip it. However, if
you are new to it or have not been doing it for long then it should be worth
reading.

Like most of the things I've covered so far, this chapter is just here to serve
as a brief introduction to give you what you will need to work through the rest
of this book. As always I recommend you research further with all the wonderful
resources out there.

## Types of Test

The 2 main types of test which we will be using during the process of building
our application are: *acceptance tests* and *unit tests*.

### Acceptance Tests {#acceptance-tests}

*Acceptance tests* are high level tests which confirm to the developer **and**
the customer that the required features have been implemented and are
working properly. Since these tests are about producing the features that the
customer requests, they are ideally produced with the customer's presence and
input and in a form which they can understand.

A typical example might be to write something down like:

> #### Listing customers when there are none will return an empty list
>
> Given there are no customers
>
> When I ask to list customers
>
> Then I should get an empty list

These simple rules could then be simply converted into automated tests using
any assert based test framework like so:

{title="xUnit style acceptance test example:", lang="php"}
~~~~~~~~
function test_that_listing_customers_when_there_are_none_will_return_an_empty_list()
{
    // Given there are no customers
    $customerRepository = new CustomerRepository();
    $customerRepository->clear();

    // When I ask to list customers
    $lister = new CustomerLister($customerRepository);
    $customers = $lister->listCustomers();

    // Then I should get an empty list
    $this->assertEquals([], $customers);
}
~~~~~~~~

This works, the comments are there to explain the test in terms the customer
can understand and the code checks the conditions are met. That said, it does
mix up the customer's language with the programmer's and it relies on the
comments being present and correct. Therefore, if you are working with the
customer to produce acceptance tests then there is a better tool for the job,
it's called *Cucumber* and in PHP it's implemented by a tool called
[Behat](http://behat.org/).

*Cucumber* scripts are tests written in a language that the customer can read
and write and are grouped as *features*. They look very much like the original
test rules we started with:

{title="Behat acceptance test example", lang="cucumber"}
~~~~~~~~
Feature: List customers
    In order to view a list of customers on the system
    As an administrator
    I need to be able to see lists of the customers information

    Scenario: Listing customers when there are none will return an empty list
        Given there are no customers
        When I ask to list customers
        Then I should get an empty list
~~~~~~~~

The language which is used in the Behat features can include any phrases that
you want. The meanings of these phases (called *snippets*) are then implemented
in PHP in *context* classes like so:

{title="Behat context example", lang="php"}
~~~~~~~~
<?php

use Behat\Behat\Tester\Exception\PendingException;
use Behat\Behat\Context\SnippetAcceptingContext;
use Behat\Gherkin\Node\PyStringNode;
use Behat\Gherkin\Node\TableNode;

/**
 * Behat context class.
 */
class FeatureContext implements SnippetAcceptingContext
{
    /**
     * @var CustomerRepository
     */
    private $customerRepository;

    /**
     * @var mixed
     */
    private $result;

    /**
     * Initializes context.
     *
     * Every scenario gets its own context object.
     * You can also pass arbitrary arguments to the context constructor through
     * behat.yml.
     */
    public function __construct()
    {
        $this->customerRepository = new CustomerRepository();
    }

    /**
     * @Given there are no customers
     */
    public function thereAreNoCustomers()
    {
        $this->customerRepository->clear();
    }

    /**
     * @When I ask to list customers
     */
    public function iAskToListCustomers()
    {
        $lister = new CustomerLister($this->customerRepository);
        $this->result = $lister->listCustomers();
    }

    /**
     * @Then I should get an empty list
     */
    public function iShouldGetAnEmptyList()
    {
        if ([] !== $this->result) {
            throw new Exception('Result was not an empty array.');
        }
    }
}
~~~~~~~~

The different *snippets* can then reused in other *scenarios* and *features*.

In this book I will be providing the *features* for each new bit of
functionality that we add and we'll use Behat to run them.

### Unit Tests

*Unit tests* are for the development team's benefit. They are not written with
the customer's help, in fact the customer may not even know they exist.
Instead, they are created by the developer as the code is written to test
little bits of code as isolated *units*. A unit is a small piece of code which
performs a specific task, often we treat each class as a unit but in reality
both multiple classes or a subsection of a class could be considered a unit.
Saying that PHPSpec, the main tool we will be using for unit testing, does
enforce that each class is a *unit*.

When doing [TDD](#tdd) the tests are actually written **before** each new bit
of code is written. This process, when used properly, actually influences what
code is written, sometimes producing surprisingly elegant solutions.

There are 2 main types of *unit testing* tools, these are *xUnit* style tools
and *BDD* style tools.

#### xUnit Frameworks

*xUnit* test tools are call so because each language has at least one of these
tools available and they are generally named *SomethingUnit* (e.g. JUnit for
Java, CppUnit for C++). The origin of these names comes from *Smalltalk's*
*SUnit* which was created by Kent Beck and was the first testing framework of
this kind. Of course, PHP has such a framework and as expected it is called
*PHPUnit*. *PHPUnit* is probably PHP's most well used unit testing framework
and was created by Sebastian Bergmann.

*xUnit* frameworks are based on assertions, each framework provides a set of
available assertion functions, these are used to check that the results our
code produces are what we expect. Some examples of the assertions functions
available in *PHPUnit* are:

{title="PHPUnit assertions example", lang="php"}
~~~~~~~~
$this->assertEquals(7, $subject->getValue());
$this->assertSame($expectedOwner, $subject->getOwner());
$this->assertFalse($subject->isBroken());
$this->assertTrue($subject->isWonderful());
$this->assertNull($subject->getNothing());
// ...
~~~~~~~~

I> A full list of *PHPUnit's* assertions can be found in [Appendix
I> A](https://phpunit.de/manual/current/en/appendixes.assertions.html) of the
I> manual.

While I will not be using PHPUnit as the main *unit testing* framework in this
book we will be making use of it at some point for certain tests. We will
also make use if its assertion library in our *Behat Contexts* for simplicity.

#### BDD Frameworks

The second type of unit testing frameworks are [BDD](#bdd) *spec* frameworks.
These are used in a very similar way to *xUnit* frameworks but the language
used in a bit different. Instead of *asserting* a condition's expectations they
are described using the work *should*. I will be using
[PHPSpec](http://www.phpspec.net/) which is a great but *highly opinionated*
BDD unit testing tool for PHP.

Using PHPSpec, the assertions we looked at for PHPUnit would written like this
instead:

{title="PHPSpec tests example", lang="php"}
~~~~~~~~
$this->getValue()->shouldReturn(7);
$this->getOwner()->shouldReturn($expectedOwner);
$this->shouldNotBeBroken();
$this->shouldBeWonderful();
$this->getNothing()->shouldReturn(null);
~~~~~~~~

The first difference you should notice is that they simply read as better
sentences than the *PHPUnit* assertions.

There is a second difference though: assertions allow you to assert the values
of anything whereas, PHPSpec's _should\*_ methods only work on return values
from the unit being tested or on *test doubles*. This means that you are much
more limited in how you can test with *PHPSpec*. However, his is not
necessarily a bad thing, it forces you to write good code and I like this (it's
not for everyone though).

#### Red, Green, Refactor: The TDD Unit Testing Process

When doing [TDD](#tdd) there is a process which defines the order in which
things should be done. This order is known as **Red, Green, Refactor**:

Red

: Red means that when we run our test suite we see a failing test. This is the
first step in writing code: *write a failing test*. The test we write should be
next smallest step we can take in our implementation that will cause the test
suite to fail. Once the test is written you must run the test suite and you
**must see it fail**.

Green

: The green step is making the failing test pass. In order to do this you only
write **the smallest amount of code needed to make the failing test pass**.
Then we run the test suite again and see that all tests pass.

Refactor

: The refactor step is the point at which the code can and should be
refactored. No functionality should be altered here, you simply tidy up the
code. After any refactorings have been made you must run the test suite to make
sure you've not broken anything.

After the *Refactor* step you go back to the **Red** step and write the next 
failing test. This process is repeated until the solution is complete.

![The Red, Green, Refactor Cycle](images/04-red-green-refactor.png)

I will run though a demonstration of this process shortly in the [Unit Testing
With PHPSpec](#unit-testing-with-phpspec) section.

## The Double Feedback Loop

*Acceptance tests* and *unit tests* support the development process in a
*double feedback loop*. *Acceptance tests* come from the *customer* in order of
priority, the *developers* then develop implement the features using *unit
tests* with the *red, green, refactor cycle* until the *acceptance tests* pass.
At this point the feature can be delivered to the *customer* and the next set
of *acceptance tests* will be produced.

![The Double Feedback Loop](images/04-double-feedback-loop.png)

## Given, When, Then

We've already seen the use of these 3 words earlier in the [Acceptance
Tests](#acceptance-tests) section. However, these 3 steps apply to all types
of tests. The *given* part sets up the preconditions, the *when* part performs
the action being tested and the *then* part checks the result. Whenever you
are writing a test it is a good idea to maintain clear grouping into these 3
stages.

We've seen this in Behat already, it's highlighted and enforce by the
*Cucumber* language. Now lets take a look an example in a *PHPUnit* & a
*PHPSpec* test:

{title="Given, When, Then example using PHPUnit", lang="php"}
~~~~~~~~
// Inside AgeCalcuatorTest
function test_calculate_the_age_of_a_customer()
{
    // Given there is a customer whose date of birth is 1982-03-15
    // And today is 2014-09-03
    $customer = new Customer('customer name', Date::fromDate('1982-03-15'));
    $today = Date::fromDate('2014-09-03');

    // When I calcuate the age of the customer
    $calculator = new AgeCalculator($today);
    $age = $calculator->calculateAge($customer);

    // Then the result should be 32
    $this->assertEquals(32, $age);
}
~~~~~~~~

{title="Given, When, Then example using PHPSpec", lang="php"}
~~~~~~~~
// Inside AgeCalcuatorSpec
function it_can_calculate_the_age_of_a_customer()
{
    // Given there is a customer whose date of birth is 1982-03-15
    // And today is 2014-09-03
    $customer = new Customer('customer name', Date::fromDate('1982-03-15'));
    $this->beConstructedWith(Date::fromDate('2014-09-03'));

    // When I calcuate the age of the customer
    $age = $calculator->calculateAge($customer);

    // Then the result should be 32
    $age->shouldBe(32);
}
~~~~~~~~

The comments are not actually necessary and it's also fine to compound the
various expressions (particularly the *when* and *then*) but the point is not
to mix up the order of the stages. I like to use vertical whitespace to
separate the setting up of the preconditions from the tests. A more condensed
version of the *PHPSpec* example would be:

{title="Condensed Given, When, Then example using PHPSpec", lang="php"}
~~~~~~~~
// Inside AgeCalcuatorSpec
function it_can_calculate_the_age_of_a_customer()
{
    $customer = new Customer('customer name', Date::fromDate('1982-03-15'));
    $this->beConstructedWith(Date::fromDate('2014-09-03'));

    $calculator->calculateAge($customer)->shouldReturn(32);
}
~~~~~~~~

I think that looks pretty neat and is very easy to read and understand what is
supposed to happen.

## Acceptance Testing with Behat

We've already seen *Behat* and what *Cucumber* tests look like, so now let's
have a go at setting up a project using them. To start off create a new folder
for the project and `cd` into it:

{lang="console"}
~~~~~~~~
$ mkdir behat-example
$ cd behat-example
~~~~~~~~

Next up let's add Behat to the project. We've already seen how to set up the
`composer.json` file but there is a simpler way. Instead, we can create the
`composer.json`, add Behat to it and run `composer update` all in one command
like so:

```console
$ composer require behat/behat:3.* --dev
```

Once it has finished Behat will be installed in the project and the `behat`
command will be available to us. Next we need to tell Behat to initialise the
project, to do this simply run:

{lang="console"}
~~~~~~~~
$ behat --init
~~~~~~~~

This command creates a directory called `features`, this is where we'll put the
tests. It also creates directory inside `features` called `bootstrap` which
contains a file called `FeatureContext.php`, this is the default context where
we can add our *snippets*.

Now let's add a feature by creating a file called
`features/list-books.feature`:

{title="features/list-books.feature", lang="cucumber"}
~~~~~~~~
Feature: List books
    In order to list books
    As a reader
    I must be able to view a list of all books stored on the system

    Scenario: Display an empty list
        Given there are no books
        When I list all books
        Then I should see an empty list
~~~~~~~~

Next run Behat:

{lang="console"}
~~~~~~~~
$ behat
~~~~~~~~

And you should see this:

{lang="console"}
~~~~~~~~
Feature: List books
    In order to list books
    As a reader
    I must be able to view a list of all books stored on the system

  Scenario: Display an empty list   # features/list-books.feature:6
    Given there are no books
    When I list all books
    Then I should see an empty list

1 scenario (1 undefined)
3 steps (3 undefined)
0m0.03s (9.00Mb)

--- FeatureContext has missing steps. Define them with these snippets:

    /**
     * @Given there are no books
     */
    public function thereAreNoBooks()
    {
        throw new PendingException();
    }

    /**
     * @When I list all books
     */
    public function iListAllBooks()
    {
        throw new PendingException();
    }

    /**
     * @Then I should see an empty list
     */
    public function iShouldSeeAnEmptyList()
    {
        throw new PendingException();
    }
~~~~~~~~

This is Behat saying that it doesn't understand the *snippets* which we have
used in the test. It also gives some template code which can be copied and
pasted into our feature context to implement these *snippets*. We could do that
but we can actually get Behat to do this for us by running:

{lang="console"}
~~~~~~~~
$ behat --append-snippets
~~~~~~~~

After this command has run, if you look in
`features/bootstrap/FeatureContext.php` you will see the template code has been
added for the 3 new *snippets*. At this point we can run Behat again:

{lang="console"}
~~~~~~~~
$ behat
~~~~~~~~

It informs us that the first *snippet* has not content and needs to be
implemented (the others have been skipped). Let's implement the first
*snippet*.

Update `features/bootstrap/FeatureContext.php` so that it looks like this:

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
<?php

use Behat\Behat\Tester\Exception\PendingException;
use Behat\Behat\Context\SnippetAcceptingContext;
use Behat\Gherkin\Node\PyStringNode;
use Behat\Gherkin\Node\TableNode;

// leanpub-start-insert
use BehatExample\BookList;
// leanpub-end-insert

/**
 * Behat context class.
 */
class FeatureContext implements SnippetAcceptingContext
{
    // leanpub-start-insert
    /**
     * @var BookList
     */
    private $bookList;
    // leanpub-end-insert

    /**
     * Initializes context.
     *
     * Every scenario gets its own context object.
     * You can also pass arbitrary arguments to the context constructor through
     * behat.yml.
     */
    public function __construct()
    {
        // leanpub-start-insert
        $this->bookList = new BookList();
        // leanpub-end-insert
    }

    /**
     * @Given there are no books
     */
    public function thereAreNoBooks()
    {
        // leanpub-start-insert
        $this->bookList->clear();
        // leanpub-end-insert
    }

    /**
     * @When I list all books
     */
    public function iListAllBooks()
    {
        throw new PendingException();
    }

    /**
     * @Then I should see an empty list
     */
    public function iShouldSeeAnEmptyList()
    {
        throw new PendingException();
    }
}
~~~~~~~~

You can try running Behat again now but it will fail since there is no
`BookList` class. To create this quickly set up the autoloader by updating the 
`composer.json` to look like this:

<<[composer.json](examples/chapter-04/behat-example/composer.json)

Then create the directory for the source code and update Composer:

{lang="console"}
~~~~~~~~
$ mkdir -p src/BehatExample
$ composer update
~~~~~~~~

Now we can create the `BookList` class:

{title="src/BehatExample/BookList.php", lang="php"}
~~~~~~~~
<?php

namespace BehatExample;

class BookList
{
    public function clear()
    {
    }
}
~~~~~~~~

Running Behat now will show the first *snippet* passing and inform that the
second snippet needs to up implemented. Let's implement the last 2 *snippets*
at once, update the `features/bootstrap/FeatureContext.php` to contain the
following:

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
<?php

use Behat\Behat\Tester\Exception\PendingException;
use Behat\Behat\Context\SnippetAcceptingContext;
use Behat\Gherkin\Node\PyStringNode;
use Behat\Gherkin\Node\TableNode;

use BehatExample\BookList;

/**
 * Behat context class.
 */
class FeatureContext implements SnippetAcceptingContext
{
    /**
     * @var BookList
     */
    private $bookList;

    // leanpub-start-insert
    /**
     * @var mixed
     */
    private $result;
    // leanpub-end-insert

    /**
     * Initializes context.
     *
     * Every scenario gets its own context object.
     * You can also pass arbitrary arguments to the context constructor through
     * behat.yml.
     */
    public function __construct()
    {
        $this->bookList = new BookList();
    }

    /**
     * @Given there are no books
     */
    public function thereAreNoBooks()
    {
        $this->bookList->clear();
    }

    /**
     * @When I list all books
     */
    public function iListAllBooks()
    {
        // leanpub-start-insert
        $this->result = $this->bookList->getBooks();
        // leanpub-end-insert
    }

    /**
     * @Then I should see an empty list
     */
    public function iShouldSeeAnEmptyList()
    {
        // leanpub-start-insert
        if ([] !== $this->result) {
            throw new Exception('Result was incorrect.');
        }
        // leanpub-end-insert
    }
}
~~~~~~~~

Again we've not implemented `BookList::getBooks()` so let's quickly do that
too:

{title="src/BehatExample/BookList.php", lang="php"}
~~~~~~~~
<?php

namespace BehatExample;

class BookList
{
    public function clear()
    {
    }

    // leanpub-start-insert
    /** @return array */
    public function getBooks()
    {
        return [];
    }
    // leanpub-end-insert
}
~~~~~~~~

Now run Behat and see the test pass:

{lang="console"}
~~~~~~~~
$ behat
Feature: List books
    In order to list books
    As a reader
    I must be able to view a list of all books stored on the system

  Scenario: Display an empty list
    Given there are no books
    When I list all books
    Then I should see an empty list

1 scenario (1 passed)
3 steps (3 passed)
0m0.01s (9.10Mb)
~~~~~~~~

Before we move on, let's quickly add another test to the feature by appending
the following to `features/list-books.feature`:

{title="features/list-books.feature", lang="cucumber"}
~~~~~~~~

    Scenario: Books are listed in alphabetical order
        Given there is a book called "Domain Driven Design" by "Eric Evans"
        And there is a book called "Refactoring" by "Martin Fowler"
        And there is a book called "Design Patterns" by "The Gang of Four"
        When I list all books
        Then I should see:
            | title                | author           |
            | Design Patterns      | The Gang of Four |
            | Domain Driven Design | Eric Evans       |
            | Refactoring          | Martin Fowler    |
~~~~~~~~

Again, if you run Behat it will say that there are new, unknown *snippets*. As
before add these by running:

{lang="console"}
~~~~~~~~
$ behat --append-snippets
~~~~~~~~

Open up `features/bootstrap/FeatureContext.php` again and update the 2 appended
methods to look like this:

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
    /**
     * @Given there is a book called :title by :author
     */
    public function thereIsABookCalledBy($title, $author)
    {
        // leanpub-start-insert
        $this->bookList->add($title, $author);
        // leanpub-end-insert
    }

    /**
     * @Then I should see:
     */
    public function iShouldSee(TableNode $table)
    {
        // leanpub-start-insert
        if ($table->getHash() !== $this->result) {
            throw new Exception('Result was incorrect.');
        }
        // leanpub-end-insert
    }
~~~~~~~~

Finally, update `BehatExample\BookList` to contain a working implementation:

<<[src/BehatExample/BookList.php](examples/chapter-04/behat-example/src/BehatExample/BookList.php)

Then, run Behat to see the tests pass:

{lang="console"}
~~~~~~~~
$ behat
Feature: List books
    In order to list books
    As a reader
    I must be able to view a list of all books stored on the system

  Scenario: Display an empty list
    Given there are no books
    When I list all books
    Then I should see an empty list

  Scenario: Books are listed in alphabetical order
    Given there is a book called "Domain Driven Design" by "Eric Evans" 
    And there is a book called "Refactoring" by "Martin Fowler"
    And there is a book called "Design Patterns" by "The Gang of Four" 
    When I list all books                                               
    Then I should see:                                                  
      | title                | author           |
      | Design Patterns      | The Gang of Four |
      | Domain Driven Design | Eric Evans       |
      | Refactoring          | Martin Fowler    |

2 scenarios (2 passed)
8 steps (8 passed)
0m0.02s (9.15Mb)
~~~~~~~~

## Mink

todo ...

### The Mink Context

todo ...

### Which Language to use in Interface Tests

todo ...

## Unit Testing with PHPSpec {#unit-testing-with-phpspec}

Now let's take a look at *unit testing*, we'll use *PHPSpec* for this. As we
work through building the application in the next section of this book, we'll
be applying the process of *acceptance testing*. However, we'll not be going
through the *unit testing* in the examples, except in certain circumstances
where there is something to learn from it. The reason for this is that it would
be a long winded, pointless and excessive process to document and it would
detract from the topic of this book. That said, all the example code I will
have been written using the full TDD process and you should do the same. This
also means that all the example code for this book will contain complete unit
tests which you can study for yourself.

Since we're not going to be highlighting the unit testing process when building
the application, we'll go through an example now to get familiar with the
process.

### Example

For our TDD example we'll create an algorithm which finds the greatest common
divisor of 2 numbers.

#### Setup

Let's start by creating a new project:

{lang="console"}
~~~~~~~~
$ mkdir phpspec-example
$ cd phpspec-example
~~~~~~~~

And configure Composer for the project:

<<[composer.json](examples/chapter-04/phpspec-example/composer.json)

{lang="console"}
~~~~~~~~
$ composer install
~~~~~~~~

Now we can start the TDD Cycle:

First of all we'll tell PHPSpec to create a new Spec file. To do this run:

{lang="console"}
~~~~~~~~
$ phpspec desc PhpspecExample\\GreatestCommonDivisorFinder
~~~~~~~~

This will create a test file called
`spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php`. To run it use:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty
~~~~~~~~

PHPSpec will say it can't find the `PhpspecExample\GreatestCommonDivisorFinder`
class and offer to create it, say **Yes** and run `phpspec run --format=pretty`
again. This time the test should pass.

I> ## Output Formatting
I>
I> The `--format=pretty` option is not necessary, I have added it because it
I> produces nice output which I can paste into this book.
I>
I> There are other formats available, these are: **progress** (the default),
I> **html**, **pretty**, **junit** and **dot**.

At this point 2 files have been created for us. The test:

{title="spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php", lang="php"}
~~~~~~~~
<?php

namespace spec\PhpspecExample;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class GreatestCommonDivisorFinderSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this->shouldHaveType('PhpspecExample\GreatestCommonDivisorFinder');
    }
}
~~~~~~~~

And the class we are going to implement:

{title="src/PhpspecExample/GreatestCommonDivisorFinder.php", lang="php"}
~~~~~~~~
<?php

namespace PhpspecExample;

class GreatestCommonDivisorFinder
{
}
~~~~~~~~

The `it_is_initializable` test has served it's purpose now so you can  remove
that from `spec\PhpspecExample\GreatestCommonDivisorFinderSpec`.

#### Red

Now we need to think what is the simplest condition we can test to make
progress towards the final goal. Let's start with when both numbers are the
same then that number is the greatest common divisor of both.

Add the following test to the spec file:

{title="spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php", lang="php"}
~~~~~~~~
    function it_returns_the_number_if_both_values_are_that_number()
    {
        $this->findGreatestDivisor(5, 5)->shouldReturn(5);
    }
~~~~~~~~

Now we have to see this fail so run:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty
~~~~~~~~

Again PHPSpec says that the `findGreatestDivisor` method does not exist and
offers to create it. Say **yes**, this will add the empty method to
`PhpspecExample\GreatestCommonDivisorFinder`.

Now run `phpspec run --format=pretty` again and you should see some red:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  x returns the number if both values are that number
        expected [integer:5], but got null.

----  failed examples

        PhpspecExample/GreatestCommonDivisorFinder
  10  x returns the number if both values are that number
        expected [integer:5], but got null.


1 specs
1 examples (1 failed)
11ms
~~~~~~~~

This tells us that the test was expecting the value `5` to be returned but
`null` was returned instead. Time to make make this test go green...

#### Green

Remember that in the green stage we must only add the smallest amount of code
to make the test pass. In this case all we need to do is return the value `5`.
Update the `PhpspecExample\GreatestCommonDivisorFinder::findGreatestDivisor()`
method and re-run the tests:

{title="src/PhpspecExample/GreatestCommonDivisorFinder.php", lang="php"}
~~~~~~~~
    public function findGreatestDivisor($a, $b)
    {
        return 5;
    }
~~~~~~~~

This time we see the green result:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number


1 specs
1 examples (1 passed)
9ms
~~~~~~~~

#### Refactor

This is the point when we do our refactoring. However, right now there's not
much to refactor so let's move straight on to the next failing test.

#### Red

For this next test let's check that when the first number is a divisor of the
second number, then the first number should be returned:

{title="spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php", lang="php"}
~~~~~~~~
    function it_returns_the_first_number_if_it_is_a_divisor_of_the_second()
    {
        $this->findGreatestDivisor(3, 9)->shouldReturn(3);
    }
~~~~~~~~

Run PHPSpec to see red:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

     PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  x returns the first number if it is a divisor of the second
        expected [integer:3], but got [integer:5].

----  failed examples

        PhpspecExample/GreatestCommonDivisorFinder
  15  x returns the first number if it is a divisor of the second
        expected [integer:3], but got [integer:5].


1 specs
2 examples (1 passed, 1 failed)
12ms
~~~~~~~~

The first test continues to pass but the second one does not as our
implementation currently only returns the integer `5`.

#### Green

Again, using the smallest change possible we can easily change this to green
by just returning the first number:

{title="src/PhpspecExample/GreatestCommonDivisorFinder.php", lang="php"}
~~~~~~~~
    public function findGreatestDivisor($a, $b)
    {
        return $a;
    }
~~~~~~~~

Now when running PHPSpec we see that both tests are successfully passing:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  ✓ returns the first number if it is a divisor of the second


1 specs
2 examples (2 passed)
11ms
~~~~~~~~

#### Refactor

There's still nothing to refactor yet so on to the next failing test.

#### Red

Let's now try the previous test the other way around: when the second number is
a divisor of the first, the second number should be returned.

{title="spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php", lang="php"}
~~~~~~~~
    function it_returns_the_second_number_if_it_is_a_divisor_of_the_first()
    {
        $this->findGreatestDivisor(9, 3)->shouldReturn(3);
    }
~~~~~~~~

Run PHPSpec again (**you have to see it fail**):

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty
~~~~~~~~

And as expected:

{lang="console"}
~~~~~~~~
      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  ✓ returns the first number if it is a divisor of the second
  20  x returns the second number if it is a divisor of the first
        expected [integer:3], but got [integer:9].

----  failed examples

        PhpspecExample/GreatestCommonDivisorFinder
  20  x returns the second number if it is a divisor of the first
        expected [integer:3], but got [integer:9].


1 specs
3 examples (2 passed, 1 failed)
13ms
~~~~~~~~

#### Green

To make this one pass we can simply return the smaller number:

{title="src/PhpspecExample/GreatestCommonDivisorFinder.php", lang="php"}
~~~~~~~~
    public function findGreatestDivisor($a, $b)
    {
        return min($a, $b);
    }
~~~~~~~~

Yet again we run the tests and see the successful results:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  ✓ returns the first number if it is a divisor of the second
  20  ✓ returns the second number if it is a divisor of the first


1 specs
3 examples (3 passed)
10ms
~~~~~~~~

#### Refactor

Still nothing to refactor so let's move on.

#### Red

How about if there's no common divisor other than then number 1? Let's write a
test for that:

{title="spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php", lang="php"}
~~~~~~~~
    function it_returns_1_if_there_is_no_greater_divisor()
    {
        $this->findGreatestDivisor(3, 5)->shouldReturn(1);
    }
~~~~~~~~

As always, run the tests and see the test fail:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  ✓ returns the first number if it is a divisor of the second
  20  ✓ returns the second number if it is a divisor of the first
  25  x returns 1 if there is no greater divisor
        expected [integer:1], but got [integer:3].

----  failed examples

        PhpspecExample/GreatestCommonDivisorFinder
  25  x returns 1 if there is no greater divisor
        expected [integer:1], but got [integer:3].


1 specs
4 examples (3 passed, 1 failed)
13ms
~~~~~~~~

#### Green

This one is a tiny bit more involved. To solve it let's say that if the lower
of the 2 numbers is not a factor of one of the numbers, then return `1`:

{title="src/PhpspecExample/GreatestCommonDivisorFinder.php", lang="php"}
~~~~~~~~
    public function findGreatestDivisor($a, $b)
    {
        $divisor = min($a, $b);

        if ($a % $divisor !== 0 || $b % $divisor !== 0) {
            $divisor = 1;
        }

        return $divisor;
    }
~~~~~~~~

Run the tests:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  ✓ returns the first number if it is a divisor of the second
  20  ✓ returns the second number if it is a divisor of the first
  25  ✓ returns 1 if there is no greater divisor


1 specs
4 examples (4 passed)
11ms
~~~~~~~~

So far so good!

#### Refactor

Finally, something to refactor! There is a duplication of the logic to check if
the `$divisor` is a factor of a variable. Let's extract it out with the
[extract method](http://refactoring.com/catalog/extractMethod.html) refactoring
like so:

{title="src/PhpspecExample/GreatestCommonDivisorFinder.php", lang="php"}
~~~~~~~~
<?php

namespace PhpspecExample;

class GreatestCommonDivisorFinder
{
    private $divisor;

    public function findGreatestDivisor($a, $b)
    {
        $this->divisor = min($a, $b);

        if (!$this->divisorIsFactorOf($a) || !$this->divisorIsFactorOf($b)) {
            $this->divisor = 1;
        }

        return $this->divisor;
    }

    private function divisorIsFactorOf($target)
    {
        return $target % $this->divisor === 0;
    }
}
~~~~~~~~

As always, run the tests to make sure they still pass:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  ✓ returns the first number if it is a divisor of the second
  20  ✓ returns the second number if it is a divisor of the first
  25  ✓ returns 1 if there is no greater divisor


1 specs
4 examples (4 passed)
11ms
~~~~~~~~

#### Red

OK, next let's try a divisor that is not `1` or either of the numbers
themselves:

{title="spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php", lang="php"}
~~~~~~~~
    function it_returns_a_divisor_of_both_numbers()
    {
        $this->findGreatestDivisor(6, 9)->shouldReturn(3);
    }
~~~~~~~~

And watch the test fail:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  ✓ returns the first number if it is a divisor of the second
  20  ✓ returns the second number if it is a divisor of the first
  25  ✓ returns 1 if there is no greater divisor
  30  x returns a divisor of both numbers
        expected [integer:3], but got [integer:1].

----  failed examples

        PhpspecExample/GreatestCommonDivisorFinder
  30  x returns a divisor of both numbers
        expected [integer:3], but got [integer:1].


1 specs
5 examples (4 passed, 1 failed)
14ms
~~~~~~~~

#### Green

We actually only have to make a very small change here to make this pass, we
simply change the `if` to a `while` and decrement the divisor in the loop:

{title="spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php", lang="php"}
~~~~~~~~
    public function findGreatestDivisor($a, $b)
    {
        $this->divisor = min($a, $b);

        // leanpub-insert-start
        while (!$this->divisorIsFactorOf($a) || !$this->divisorIsFactorOf($b)) {
            $this->divisor--;
        }
        // leanpub-insert-end

        return $this->divisor;
    }
~~~~~~~~

Run the tests:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  ✓ returns the first number if it is a divisor of the second
  20  ✓ returns the second number if it is a divisor of the first
  25  ✓ returns 1 if there is no greater divisor
  30  ✓ returns a divisor of both numbers


1 specs
5 examples (5 passed)
11ms
~~~~~~~~

Everything has passed, and if you look over the code you should see we've
reached a final solution to *find the greatest common divisor or 2 numbers*.

If you really want to double check it you could add this extra test but it will
pass straight away:

{title="spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php", lang="php"}
~~~~~~~~
    function it_returns_the_greatest_divisor_of_both_numbers()
    {
        $this->findGreatestDivisor(12, 18)->shouldReturn(6);
    }
~~~~~~~~

#### Refactor

Looking at the code we've produced I'd say it's pretty neat already and doesn't
require any additional refactoring. Maybe we could just add some *docblocks*
for type information.

#### The Result

And here it is, a complete solution to our original problem, achieved by TDD:

<<[src/PhpspecExample/GreatestCommonDivisorFinder.php](examples/chapter-04/phpspec-example/src/PhpspecExample/GreatestCommonDivisorFinder.php)


## Test Doubles

We've already heard of *test doubles* and how they can be used to help test
units of code in isolation by replacing the unit's dependencies. Now let's take
a look at how this is actually done.

### Types of Test Doubles

*Tests doubles* take on different forms as they are used for different
purposes.  Each of these different types of test double are used to solve a
different problem. Let's take a look at the different types.

#### Dummy

A *dummy* is the simplest *test double*, it simply serves as a placeholder for
a dependency. It's essentially an empty class which implements the dependency's
interface.



#### Stub

#### Spy

#### Fake

#### Mock

### Testing Dependencies Which Don't Exist Yet

## Resources

