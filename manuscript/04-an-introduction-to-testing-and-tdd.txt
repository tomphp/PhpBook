# An Introduction to Testing and TDD

Here's I'm going to quickly cover some of the testing tools we will be using
and give a brief introduction to TDD. This is an optional chapter so if you are
familiar with these tools and TDD feel free to skip it. However, if you are new
to it or feel you would like to understand it better then it's worth a read.

Like most of the things I've covered so far, this chapter is just here to serve
as a brief introduction to give you what you will need to work through the rest
of this book. As always I recommend you research further with all the wonderful
resources out there.

## Types of Test

The 2 main types of testing I will be using the process of building our
application are *acceptance tests* and *unit tests*.

### Acceptance Tests {#acceptance-tests}

*Acceptance tests* are high level tests which confirm to the customer that the
features they've asked for are implemented and are working properly. Since
these tests are about producing the feature that the customer requests, they
are ideally produced with the customer's presence and input, in a form which
they can understand.

A typical example might be to write something down like:

> # Listing customers when there are none will return an empty list
>
> Given there are no customers
>
> When I ask to list customers
>
> Then I should get an empty list

These could then be simply implemented in any assert based test framework like
so:

{title="xUnit style acceptance test example:", lang="php"}
~~~~~~~~
function test_listing_customers_where_there_a_none_will_return_an_empty_list()
{
    // Given there are no customers
    $customerRepository = new CustomerRepository();
    $customerRepository->removeAll();

    // When I ask to list customers
    $lister = new CustomerLister($customerRepository);
    $customers = $lister->listCustomers();

    // Then I should get an empty list
    $this->assertEquals([], $customers);
}
~~~~~~~~

This works, the comments are there to explain the test in terms the customer can
understand and the code checks the conditions are met. That said it does mix up
the 2 customers language with the programmers and it relies on comments being
present and correct. Therefore, if you are working the customer on producing
acceptance tests then there is a better tool for the job, it's called
*cucumber* and it PHP it's implemented by a tool called
[Behat](http://behat.org/).

*Cucumber* scripts are tests written in a language that the customer can read
and write and are grouped as *features*. They look very much like the original
test rules we started with:

{title="Behat acceptance test example", lang="cucumber"}
~~~~~~~~
Feature: List customers
    In order to view a list of customers on the system
    As an administrator
    I need to be able to see lists of the customers information

    Scenario: Listing customers when there are none will return an empty list
        Given there are no customers
        When I ask to list customers
        Then I should get an empty list
~~~~~~~~

The language which is used in the Behat features can include any phrases that
you want to include. The meanings of these phases (called *snippets*) are then
implemented in PHP in *context* classes like so:

{title="Behat context example", lang="php"}
~~~~~~~~
<?php

use Behat\Behat\Tester\Exception\PendingException;
use Behat\Behat\Context\SnippetAcceptingContext;
use Behat\Gherkin\Node\PyStringNode;
use Behat\Gherkin\Node\TableNode;

/**
 * Behat context class.
 */
class FeatureContext implements SnippetAcceptingContext
{
    /**
     * @var CustomerRepository
     */
    private $customerRepository;

    /**
     * @var mixed
     */
    private $result;

    /**
     * Initializes context.
     *
     * Every scenario gets its own context object.
     * You can also pass arbitrary arguments to the context constructor through
     * behat.yml.
     */
    public function __construct()
    {
        $this->customerRepository = new CustomerRepository();
    }

    /**
     * @Given there are no customers
     */
    public function thereAreNoCustomers()
    {
        $this->customerRepository->removeAll();
    }

    /**
     * @When I ask to list customers
     */
    public function iAskToListCustomers()
    {
        $lister = new CustomerLister($this->customerRepository);
        $this->result = $lister->listCustomers();
    }

    /**
     * @Then I should get an empty list
     */
    public function iShouldGetAnEmptyList()
    {
        if ([] !== $this->result) {
            throw new Exception('Result was not an empty array.');
        }
    }
}
~~~~~~~~

The different *snippets* can then reused in other *scenarios* and *features*.

In this I will be providing the *features* for each new bit of functionality
that we add and well use Behat to test them.

### Unit Tests

*Unit tests* are for the development teams benefit, they are not written with
the customer's help, in fact the customer may not even know they exist.
Instead, they are create by the developer as the code is written to test little
bits of code as isolated *units*. A unit is a small piece of code which
performs a specific task, often we treat each class as a unit but in reality a
multiple classes or a subsection of a class could be considered a unit. Saying
that PHPSpec, the main tool we will be using for unit testing, does treat each
individual class as a *unit*.

When doing [TDD](#tdd) the tests are actually written before each new bit of 
code is written. This process when used properly actually influences what code
is written, sometimes producing surprisingly elegant solutions.

There are 2 main types of *unit testing* tools, these are *xUnit* style tools
and *BDD* style tools.

#### xUnit Frameworks

*xUnit* test tools are call so because each language has a least one of these
tools available and they are generally named *SomethingUnit* (e.g. JUnit for
Java, CppUnit for C++). The origin of these names comes from *Smalltalk's*
*SUnit* which was created by Kent Beck and was the first testing framework of
this kind. Of course, PHP has such a framework and as expected it is called
*PHPUnit*. *PHPUnit* is probably PHP's most well used unit testing framework
and was created by Sebastian Bergmann.

*xUnit* frameworks are based on assertions, each framework provides a set of
available assertion functions, these are used to check the results our code
produces are what we expect. Some examples of the assertions functions
available in *PHPUnit* are:

{title="PHPUnit assertions example", lang="php"}
~~~~~~~~
$this->assertEquals(7, $subject->getValue());
$this->assertSame($expectedOwner, $subject->getOwner());
$this->assertFalse($subject->isBroken());
$this->assertTrue($subject->isWonderful());
$this->assertNull($subject->getNothing());
// ...
~~~~~~~~

A full list of *PHPUnit's* assertions can be found in [Appendix
A](https://phpunit.de/manual/current/en/appendixes.assertions.html) of the
manual.

While I will not be using PHPUnit as the main *unit testing* framework in this
book we will be making use of it at some point for certain tests. We will
also make use if its assertion library in our *Behat Contexts* for simplicity.

#### BDD Frameworks

The second type of unit testing frameworks are [BDD](#bdd) *spec* frameworks.
These are used in a very similar way to *xUnit* frameworks but the language
used in a bit different. Instead of *asserting* a conditions expectations are
described using the work *should*. I will be using
[PHPSpec](http://www.phpspec.net/) which is a great but *highly opinionated*
BDD unit testing tool for PHP.

Using PHPSpec the assertions we looked at for PHPUnit would written like this
instead:

{title="PHPSpec tests example", lang="php"}
~~~~~~~~
$this->getValue()->shouldReturn(7);
$this->getOwner()->shouldReturn($expectedOwner);
$this->shouldNotBeBroken();
$this->shouldBeWonderful();
$this->getNothing()->shouldReturn(null);
~~~~~~~~

The first difference you should notice is that they just read as better
sentences than the *PHPUnit* assertions.

There is a second difference though: assertions allow you to assert the values
of anything whereas, PHPSpec's _should\*_ methods only work on return values
from the unit being tested or on test doubles. This means that you are much
more limited in how you can test with *PHPSpec* but this is not necessarily a
bad thing, it forces you to write good code and I like this (it's not for
everyone though).

#### Red, Green, Refactor: The TDD Unit Testing Process

When doing [TDD](#tdd) there is a process to the order in which things should
be done. This order is known as **Red, Green, Refactor**:

Red

: Red means that when we run our test suite we see a failing test. This is the
first step in writing code: *write a failing test*. The test we write should be
next smallest step we can take in our implementation that will cause the test
suite to fail. Once the test is written you must run the test suite and you
**must see it fail**.

Green

: The green step is making the failing test pass. In order to do this you only
write **the smallest amount of code needed to make the failing test pass**.
Then we run the test suite again and see that all tests pass.

Refactor

: The refactor step is the point at which the code can and should be
refactored.  No functionality should be altered here, you simply tidy up the
code. After any refactorings have been made you must run the test suite to make
sure you've not broken anything.

After the *Refactor* step you go back to the **Red** step and write the next 
failing test. This process is repeated until the solution is complete.

![The Red, Green, Refactor Cycle](images/04-red-green-refactor.png)

I will run though a demonstration of this process shortly in the [Unit Testing
With PHPSpec](#unit-testing-with-phpspec) section.

## Given, When, Then

We've already seen the use of these 3 words earlier in the [Acceptance
Tests](#acceptance-tests) section. However, these 3 steps apply to all types
of tests. The *given* part sets up the preconditions, the *when* part performs
the action being tested and the *then* part checks the result. Whenever you
are writing a test it is a good idea to maintain clear grouping into these 3
stages.

We've seen this in Behat already, it's highlighted and enforce by the *Cucumber*
language. Now lets take a look an example in a *PHPUnit* & a *PHPSpec* test:

{title="Given, When, Then example using PHPUnit", lang="php"}
~~~~~~~~
// Inside AgeCalcuatorTest
function test_calculate_the_age_of_a_customer()
{
    // Given there is a customer who's date of birth is 1982-03-15
    // And today is 2014-09-03
    $customer = new Customer('customer name', Date::fromDate('1982-03-15'));
    $today = Date::fromDate('2014-09-03');

    // When I calcuate the age of the customer
    $calculator = new AgeCalculator($today);
    $age = $calculator->calculateAge($customer);

    // Then the result should be 32
    $this->assertEquals(32, $age);
}
~~~~~~~~

{title="Given, When, Then example using PHPSpec", lang="php"}
~~~~~~~~
// Inside AgeCalcuatorSpec
function it_can_calculate_the_age_of_a_customer()
{
    // Given there is a customer who's date of birth is 1982-03-15
    // And today is 2014-09-03
    $customer = new Customer('customer name', Date::fromDate('1982-03-15'));
    $this->beConstructedWith(Date::fromDate('2014-09-03'));

    // When I calcuate the age of the customer
    $age = $calculator->calculateAge($customer);

    // Then the result should be 32
    $age->shouldBe(32);
}
~~~~~~~~

The comments are not actually necessary and it's also find to compound the
various expressions (particularly the *when* and *then*) but the point is not
to mix up the orders of each stage. I also like to use vertical whitespace to 
separate the setting up of the preconditions from the tests. A more condensed
version of the *PHPSpec* example would be:

{title="Condensed Given, When, Then example using PHPSpec", lang="php"}
~~~~~~~~
// Inside AgeCalcuatorSpec
function it_can_calculate_the_age_of_a_customer()
{
    $customer = new Customer('customer name', Date::fromDate('1982-03-15'));
    $this->beConstructedWith(Date::fromDate('2014-09-03'));

    $calculator->calculateAge($customer)->shouldReturn(32);
}
~~~~~~~~

I think that looks pretty neat and is very easy to read and understand what is
supposed to happen.

## Acceptance Testing with Behat

We've already seen *Behat* and seen what *Cucumber* tests look like so lets
have a go at setting up a project using them. To start off create a new folder
for the project and `cd` into it:

```
$ mkdir behat-example
$ cd behat-example
```

Next up let's add Behat to the project. We've already seen how to set up the
`composer.json` file but there is a simpler way; we can create it, add 
the `composer.json`, add Behat to it and run `composer update` all in one
command like so:

```
$ composer require behat/behat:3.* --dev
```

Once it has run let Behat will be installed in the project and the `behat`
command is not available to us. Now we need to tell Behat to initialise the project,
to do this simple run:

```
$ behat --init
```

This command creates a directory called `features`, these is where we'll put
the tests. It also creates directory called `features/bootstrap` which contains
a file called `FeatureContext.php`, this is the default context where we can
add our *snippets*.

Now let's add a feature:

{title="Example feature", lang="cucumber"}
~~~~~~~~
Feature: 
    In order to
    As a
    I must

    Scenario:
        Given
        When
        Then
~~~~~~~~

# Mink & Selenium

### The Mink Context

### Which Language to use in Interface Tests

## Unit Testing with PHPSpec {#unit-testing-with-phpspec}

## Test Doubles

### Testing Dependencies Which Don't Exist Yet

## The Double Feedback Loop

## Resources
