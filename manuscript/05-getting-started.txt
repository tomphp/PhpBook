# Getting Started

## The Application

A brief description of the application we are going to build is as follows:

> The aim is to produce a website which allows *users* of the site to
> *view* and *rate* cocktail recipes submitted by other users, as well as
> *submit their own*. Any *visitors* to the site can view the list *sorted by
> rating*, but they must *register* with a *username*, *email* and *password*
> in order to *rate* or *add* a *receipe*.
> 
> Ratings will be *star* ratings with *users* being able to *rate* a recipe
> with 1 to 5 *stars*.
> 
> *Quantities* can be entered as either *millilitres (ml)*, *fluid ounces (fl
> oz)* or *teaspoons (tsp)*.
> 
> The cocktail ingredients available are limited to a selection which can only
> be added to by an *administrator*.

Now we've got a basic understand of application we are going to build let's
take a quick look at the list of [user stories](#user-stories). These are
listed in order of priority.

* A visitor can view a list of recipes
* A visitor can view a recipe
* A visitor can register and become a user
* A visitor can login to become a user
* A user can rate a recipe
* A user can add a recipe
* An administrator can add an ingredient

We will proceed to implement each of these stories in order. This may seem like
a very basic application but it will provide enough functionality to give a
good example of how to start building a well designed, extendible application.
Also, because this is being developed emulating an *agile* approach, details
may change as it progresses and extra features may be requested.

## Creating the Project

Before jumping in let's quickly set up a project by running:

{lang="console"}
~~~~~~~~
$ mkdir cocktail-rater
$ cd cocktail-rater
~~~~~~~~

Then add the following `composer.json`

<<[composer.json](examples/chapter-05/scenario1/composer.json)

I> ### PhpSpec Version
I>
I> You may have notice that the PHPSpec requirement is for a development
I> version. The reason for this is that there are some features which we will
I> be using which are not in the stable release, when this changes I will
I> update this accordingly.

Run composer to install the test tools:

{lang="console"}
~~~~~~~~
$ composer install
~~~~~~~~

Next up we can quickly configure PHPSpec to format its output as pretty by
default so that we don't need to put it on the command line every time we run
it. To do this create a file called `phpspec.yml` with the following contents:

{title="phpspec.yml", format="yaml"}
~~~~~~~~
formatter.name: pretty
~~~~~~~~

Finally, initialise Behat ready to start development:

{lang="console"}
~~~~~~~~
$ behat --init
~~~~~~~~

All done! Now we can start...

## The First Story

Let's look at the first [story](#user-stories). One thing to note is that a
story is not a specification, it's intentionally vague and it's purpose is to
exist as a *request for conversation*. When it is time to implement a story the
team (which includes the customer) should discuss the story and decide on the
details, this will result in the generation of the acceptance tests. For the
purpose of this book I'll provide the story and tests as though this conversation
has already taken place. So, here's the story card for the first feature:

> A visitor can view a list of recipes
>
> * Displays an empty list if there are no recipes
> * Recipes display the *name of the cocktail*, *the rating* and the *name of 
> the user who submitted it*
> * The list should be presented it *decending* order of rating

From this information we can add the following feature to the project:

<<[features/visitors-can-list-recipes.feature](examples/chapter-05/scenario1/features/visitors-can-list-recipes.feature)

If you try to run Behat with this feature it will say that the context has missing
steps, to add the required snippets run:

{lang="console"}
~~~~~~~~
$Â behat --append-snippets
~~~~~~~~

Now we can start working to get these *scenarios* to pass.

## Application Structure

Before jumping straight into writing code let's just take a small moment to
take a look at the structure we plan to use to build the application.

![Proposed Application Structure](images/05-application-structure.png)

The core part of the application will be the *domain model*, this will consist
of our modelled interpretation of the business rules. It will have no knowledge
of how or where the data in stored, the user interface or any non-business related
implementation details. To achieve this level of separation we'll use *inversion
of control* to let the other layers *plug in* to the domain layer.

Behind the *domain model* there will be storage implementation layer for our
chosen storage system. The storage system has not yet been decided so we'll
make use of SQLite until we decide. The reason of this choice is that SQLite
allows the access of a database file without needing to set up a database
server and it's easier to use that writing our own file based storage system.

In chapter 3 I introduced [CQRS](#cqrs) and stated that while we are not going
to implement it in our application we will make a distinction between *command*
and *query* interactions with the application. Therefore, in front of the *domain
model* we'll have a layer of *commands* and *queries*, all interactions with
the *domain model* from the *GUI* will go through these.

Finally, we'll have the GUI website. We'll start of just mocking this up with
some basic HTML but as our application becomes more complete we can make use
of a modern MVC[^mvc] framework. Again we won't worry about which one until
later on.

[^mvc]: The [Model View Controller](http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) design pattern.

## Scenario: View an empty list of recipes

So here's the scenario which we want to get to pass:

{title="View an empty list of recipes", lang="cucumber"}
~~~~~~~~
    Scenario: View an empty list of recipes
        Given there are no recipes
        When I request a list of recipes
        Then I should see an empty list
~~~~~~~~

We're going to use TDD to work from the *outside in*. What I mean be this is
rather than trying to build the model and then get it to do what we need it
to do, we'll start with what we want it to do and let that help create the
model.

### Fleshing out the FeatureContext

Behat has already added the required *snippet* templates to the
`FeatureContext` so let's try to pencil in what we want to happen. Take a look
at the code I have added first then I'll explain it:

<<[features/bootstrap/FeatureContext.php](examples/chapter-05/scenario1/features/bootstrap/FeatureContext.php)

The thinking I have used here goes something like this:

> In order to list recipes we'll create a query object then somehow we'll
> process that query to get the result. This process will involve fetching
> all existing recipes and returning the result.

The first line of our test states *"Given there are no recipes"*. Now I'm going
to use the term *Respoitory* for the place where objects will be stored, so to
make this pass we've got to ensure that the *Repository* for storing recipes is
empty. I've also stated that we're not going to worry about what storage system
we will be using until later, so in the mean time I've decided to create a
simple test repository which we'll use to emulate the repository functionality.
I've decided to name this
`CocktailRater\Testing\Repository\TestRecipeRepository`.

With this information, the first thing we need to do is create an instance of
this repository. I've done this in the `FeatureContext` method called
`beforeScenario`.

W> ### The @BeforeScenario Annotation
W>
W> You may also notice that I've added `@BeforeScenario` to the
W> docblock for this method, this is known as an *annotation* and is required
W> to inform Behat to run this method before it runs each *scenario*.

Next we *clear* the repository to ensure there are no recipes in the
`thereAreNoRecipes` method.

Then next line of the test states *"When I request a list of recipes"*. For
this we create the query object, run it and store the result. I've decided that
the *running* of the query will be done by a *query handler* and therefore
we'll use the verb *handle* to run it. Also, we know that the *query handler*
will need to fetch recipes from the *repository* so we pass it to the *handler*
via the constructor. All this is put into action in the
`iRequestAListOfRecipes` method in our `FeatureContext`.

Finally, the last line of the test says *"Then I should see an empty list"*, to
do this we'll simple check the value in the query result. In order to make a
Behat snippet fail it must throw an exception. However, rather than writing our
own checking methods I've decided to make use of the *assert* methods provided
by PHPUnit. For this test we've used 2 asserts, one to check the result is an
*array* and the second to check it's empty.

At this point if you try to run Behat you'll see PHP error messages since we've
referenced classes which don't exist. To fix this lets add the classes.

### Writing the Code

The first list of the test requires the *respository* and that is has a method
called `clear`. Let's quickly add that:

{title="src/CocktailRater/Testing/Repository/TestRecipeRepoitory.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Testing\Repository;

use CocktailRater\Domain\Repository\RecipeRepository;

final class TestRecipeRepository 
{
    public function clear()
    {
    }
}
~~~~~~~~

That's nice and simple for now, you may have noticed the use of the `final`
keyword. For now I'm just going to say that I add this to my classes by
default, this is not required but is my preference, I'll explain the reason for
this a bit later on.

Next up let's create the `ListRecipesQuery`. A query class will contain the
parameters for the query, in this case there are none so the class simply looks
like this:

<<[src/CocktailRater/Application/Visitor/Query/ListRecipesQuery.php](examples/chapter-05/scenario1/src/CocktailRater/Application/Visitor/Query/ListRecipesQuery.php)

I've chosen to add `Visitor` to the namespace since these are queries which
will be made by *vistors*.

Now for the interesting bit, the `ListRecipesHandler`. From looking at the
`FeatureContext` it needs to take a *repository* as a constructor parameter,
the query as a parameter to the `handle` method and return some object which
has a `getRecipes` method.

Here we don't want to depend on our test repository so we'll create an
interface which will be used in its place. For the return value we'll create a
class called `CocktailRater\Application\Visitor\Query\ListRecipesResult`.
Without further ado, here it is:

<<[src/CocktailRater/Application/Visitor/Query/ListRecipesHandler.php](examples/chapter-05/scenario1/src/CocktailRater/Application/Visitor/Query/ListRecipesHandler.php)

At this point we've created all this classes that were referenced from the 
`FeatureContext` but this last one has just introduced 2 more: the 
`RecipeRepository` and the `ListRecipesResult` so let's add them quickly too
(this is what I was referring to when I said we'd work from the *outside in*):

<<[src/CocktailRater/Application/Visitor/Query/ListRecipesResult.php](examples/chapter-05/scenario1/src/CocktailRater/Application/Visitor/Query/ListRecipesResult.php)

<<[src/CocktailRater/Domain/Repository/RecipeRepository.php](examples/chapter-05/scenario1/src/CocktailRater/Domain/Repository/RecipeRepository.php)

The `ListRecipesResult` class simply returns the and empty list from
`getRecipes` which is all it needs to do now.

The `RecipeRepository` interface currently has no methods. This is because the
only method currently existing in out test repository is `clear`, however this
method is only relevant for the tests, there is now requirement for this in the
actual application.

Now there's only one thing left to do: the `ListRecipesHandler` class requires
a `RecipeRepository` to be provided to the constructor but, in the `FeatureContext`
we've provided a `TestRecipeRepository`. To make this work we need to make the
test repository implement the interface:

{title="src/CocktailRater/Testing/Repository/TestRecipeRepoitory.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Testing\Repository;

use CocktailRater\Domain\Repository\RecipeRepository;

// leanpub-start-insert
final class TestRecipeRepository implements RecipeRepository
// leanpub-end-insert
{
    public function clear()
    {
    }
}
~~~~~~~~

At this point should be able to run Behat and see the first *scenario* pass:

{lang="console"}
~~~~~~~~
$ behat
~~~~~~~~

## Scenario: View a list with 1 item

We got the first scenario to pass with very no real logic, to get the next one
to pass we need to start filling in some of the blanks that we created.

### Updating the FeatureContext

Just like last time we can start by filling adding some content to our 2
remaining methods in the `FeatureContext`. Here I'd just like to point out
that you make find it easier to work with one at a time, but for the sake of
not making this book too long I'm condensing the processes down a bit.

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
<?php

use Behat\Behat\Context\SnippetAcceptingContext;
use Behat\Behat\Tester\Exception\PendingException;
use Behat\Gherkin\Node\PyStringNode;
use Behat\Gherkin\Node\TableNode;
use CocktailRater\Application\Visitor\Query\ListRecipes;
use CocktailRater\Application\Visitor\Query\ListRecipesHandler;
use CocktailRater\Application\Visitor\Query\ListRecipesQuery;
use CocktailRater\Application\Visitor\Query\ListRecipesQueryHandler;
// leanpub-start-insert
use CocktailRater\Domain\Rating;
use CocktailRater\Domain\Recipe;
use CocktailRater\Domain\User;
use CocktailRater\Domain\Username;
// leanpub-end-insert
use CocktailRater\Testing\Repository\TestRecipeRepository;
use PHPUnit_Framework_Assert as Assert;

/**
 * Behat context class.
 */
class FeatureContext implements SnippetAcceptingContext
{
    // ...

    /**
     * @Given there's a recipe for :name by user :user with :rating stars
     */
    public function theresARecipeForByUserWithStars($name, $user, $rating)
    {
        // leanpub-start-insert
        $this->recipeRepository->add(
            new Recipe(
                $name,
                new Rating($rating),
                new User(new Username($user))
            )
        );
        // leanpub-end-insert
    }

    /**
     * @Then I should see a list of recipes containing:
     */
    public function iShouldSeeAListOfRecipesContaining(TableNode $table)
    {
        // leanpub-start-insert
        $callback = function ($recipe) {
            return [
                (string) $recipe['name'],
                (float) $recipe['rating'],
                (string) $recipe['user']
            ];
        };

        Assert::assertEquals(
            array_map($callback, $this->result->getRecipes()),
            array_map($callback, $table->getHash())
        );
        // leanpub-end-insert
    }
}
~~~~~~~~

In `theresARecipeForByUserWithStars` we're creating a new `Recipe` object. The
`Recipe` needs a name, rating and user so we can add what we think look like
sensible dependencies via the constructor. We also *add* this new object to the
repository.

In the `iShouldSeeAListOfRecipesContaining` method we compare the results
returned from the query with the table of expected results using PHPUnit's
`assertEquals`. I've also used `array_map` to ensure both arrays contain the
same types since all values in Behat tables are strings.

### Adding new Classes to the Model

I> ### Unit Tests
I>
I> Before continuing I'd just like to point out that up until this point I've
I> not created any unit tests. From this point on I'll be using them for all
I> development in the *domain model*. However, I won't be showing them or the
I> process but they're all available in the example code if you want to study
I> them.

Let's start off by adding the new classes to the model:

{title="src/CocktailRater/Domain/Recipe.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Domain;

final class Recipe
{
    /** @param string $name */
    public function __construct($name, Rating $rating, User $user)
    {
    }
}
~~~~~~~~

{title="src/CocktailRater/Domain/Rating.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Domain;

final class Rating
{
    /** @var float $value */
    public function __construct($value)
    {
    }
}
~~~~~~~~

{title="src/CocktailRater/Domain/User.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Domain;

final class User
{
    /** @var string $username */
    public function __construct(Username $username)
    {
    }
}
~~~~~~~~

{title="src/CocktailRater/Domain/Username.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Domain;

final class Username
{
    /** @param string $value */
    public function __construct($value)
    {
    }
}
~~~~~~~~

We also need to add the `add` method to the repository:

{title="src/CocktailRater/Domain/Repository/RecipeRepository.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Domain\Repository;

// leanpub-start-insert
use CocktailRater\Domain\Recipe;
// leanpub-end-insert

interface RecipeRepository
{
    // leanpub-start-insert
    public function add(Recipe $recipe);
    // leanpub-end-insert
}
~~~~~~~~

This also means we need to add the method to the `TestRecipeRepository`:

{title="src/CocktailRater/Testing/Repository/TestRecipeRepository.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Testing\Repository;

// leanpub-start-insert
use CocktailRater\Domain\Recipe;
// leanpub-end-insert
use CocktailRater\Domain\Repository\RecipeRepository;

final class TestRecipeRepository implements RecipeRepository
{
    // leanpub-start-insert
    public function add(Recipe $recipe)
    {
    }
    // leanpub-end-insert

    public function clear()
    {
    }
}
~~~~~~~~

### Making the Scenario Pass

At this point only the last line of the scenario should be failing. We've got
the template of the model laid out so we just need to fill in the details. To
start with let's take a look at how the query handler will work:

<<[src/CocktailRater/Domain/Repository/RecipeRepository.php](examples/chapter-05/scenario2/src/CocktailRater/Domain/Repository/RecipeRepository.php)

It's quite simple, it fetches all recipes from the repository, adds the details
of each one to the result object and returns it. This does however mean we've
got a bit of work to do to get it all working. First up let's update the classes
in the *domain model*:

<<[src/CocktailRater/Domain/Recipe.php](examples/chapter-05/scenario2/src/CocktailRater/Domain/Recipe.php)

<<[src/CocktailRater/Domain/Rating.php](examples/chapter-05/scenario2/src/CocktailRater/Domain/Rating.php)

<<[src/CocktailRater/Domain/User.php](examples/chapter-05/scenario2/src/CocktailRater/Domain/User.php)

<<[src/CocktailRater/Domain/Username.php](examples/chapter-05/scenario2/src/CocktailRater/Domain/Username.php)

In the *domain model* we've started to make use of Benjamin Eberlei's
*[Assert](https://github.com/beberlei/assert)* library. To do this we need to
install the dependency with composer by running:

{lang="console"}
~~~~~~~~
$ composer require beberlei/assert:@stable
~~~~~~~~

A> ### The Assert Library
A>
A> Adding a dependency to a 3rd party library is something that should not be
A> done without serious consideration. A better approach is to use *Inversion
A> of Control* to make the model depend on the library via a layer of
A> abstraction. The [Adapter](http://en.wikipedia.org/wiki/Adapter_pattern)
A> design pattern is a very good tool for this job.
A>
A> So, with that said way am I using the Assert library from within to domain
A> model? The reason is: it's a well used and stable library with utility
A> methods which have no side effects. More importantly I'm using it in a way
A> which adds, what I think, is a missing feature in the PHP language; namely
A> typehints for scalar types and arrays.
A>
A> There is an interesting discussion with Mathais Verraes on the [DDDinPHP
A> Google Group](https://groups.google.com/forum/#!msg/dddinphp/YGogT1NSbO0/u22c4dgoxdEJ)
A> about adding dependencies to 3rd party libraries to your domain model. The
A> bottom line though it before doing this you should exercise extreme
A> consideration of what you are about to do.

One thing which may have caught your eye in the `User` class is the
`fromValues` *static* method. This is known as a *named constructor* its a 
way in which we can provide alternate constructors for classes and is one of
the few valid uses of the *static* keyword since it maintains no state and
works in a purely *functional* way. At this point in time this has only been
used in the unit tests but the neater tests I felt were a good enough reason
to add it.

Another thing we have done here is restrict the value allowed for a rating to
be between 1 and 5. If it falls outside of this range we throw and exception.
The appropriate exception to be throw here is PHP SPL's `OutOfBoundsException`.
However, rather than throw it directly we've extended it so that it can be
tracked down to be coming from our application. Let's take a quite look at it:

<<[src/CocktailRater/Domain/Exception/OutOfBoundsException.php](examples/chapter-05/scenario2/src/CocktailRater/Domain/Exception/OutOfBoundsException.php)

Again you'll notice the use of a *named constructor*, I think this is a really
neat way to keep the exception messages neat and tidy and in a relevant place.

Next let's quickly update the `ListRecipesResult` class:

<<[src/CocktailRater/Application/Visitor/Query/ListRecipesResult.php](examples/chapter-05/scenario2/src/CocktailRater/Application/Visitor/Query/ListRecipesResult.php)

Finally, we need to update the functionality of the repository to return the
list of recipes stored:

<<[src/CocktailRater/Domain/Repository/RecipeRepository.php](examples/chapter-05/scenario2/src/CocktailRater/Domain/Repository/RecipeRepository.php)

<<[src/CocktailRater/Testing/Repository/TestRecipeRepository.php](examples/chapter-05/scenario2/src/CocktailRater/Testing/Repository/TestRecipeRepository.php)

As you can see, we've created an in memory test repository which is good enough
for what we need so far.

You can now run Behat and watch the second scenario pass.

## Scenario: Recipes are sorted by rating

You may have already noticed that when you run Behat now most of our final
scenario already passes, the only thing which fails is the order in which
the recipes are listed. To fix this we can just straight into the 
`ListRecipesHandler` and sort the recipes:

<<[src/CocktailRater/Application/Visitor/Query/ListRecipesHandler.php](examples/chapter-05/scenario3/src/CocktailRater/Application/Visitor/Query/ListRecipesHandler.php)

We also need to add new methods to both the `Recipe` and `Rating` classes:

{title="src/CocktailRater/Domain/Recipe.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Domain;

use Assert\Assertion;
// leanpub-start-insert
use CocktailRater\Domain\Recipe;
// leanpub-end-insert

final class Recipe
{
    // ...

    public function isHigherRatedThan(Recipe $other)
    {
        return $this->rating->isHigherThan($other->rating);
    }
}
~~~~~~~~

{title="src/CocktailRater/Domain/Rating.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Domain;

use Assert\Assertion;
use CocktailRater\Domain\Exception\OutOfBoundsException;

final class Rating
{
    // ...

    /** @return bool */
    public function isHigherThan(Rating $other)
    {
        return $this->value > $other->value;
    }
}
~~~~~~~~

And that's it, the first feature is done!

## Some Thoughts

todo:

dto vs array return value

## What Next?

So far we've managed to get the first feature's tests to pass. However, we've
done it in quite an isolated way by considering this single *query* on it's
own. In the next chapter we'll quickly add the second feature then we can 
analyse the two to find similarities. We'll then use this knowledge to
*refactor* what we have into a more generic form. After that we'll try display
the application's output on a page.
