# Getting Started

## The Application

A brief description of the application we are going to build is as follows:

> The aim is to produce a website which allows *users* of the site to
> *view* and *rate* cocktail recipes submitted by other users, as well as
> *submit their own*. Any *visitors* to the site can view the list *sorted by
> rating*, but they must *register* with a *username*, *email* and *password*
> in order to *rate* or *add* a *receipe*.
> 
> Ratings will be *star* ratings with *users* being able to *rate* a recipe
> with 1 to 5 *stars*.
> 
> *Quantities* can be entered as either *millilitres (ml)*, *fluid ounces (fl
> oz)* or *teaspoons (tsp)*.
> 
> The cocktail ingredients available are limited to a selection which can only
> be added to by an *administrator*.

Now we've got a basic understand of application we are going to build let's
take a quick look at the list of [user stories](#user-stories). These are
listed in order of priority.

* A visitor can view a list of recipes
* A visitor can view a recipe
* A visitor can register and become a user
* A visitor can login to become a user
* A user can rate a recipe
* A user can add a recipe
* An administrator can add an ingredient

We will proceed to implement each of these stories in order. This may seem like
a very basic application but it will provide enough functionality to give a
good example of how to start building a well designed, extendible application.
Also, because this is being developed emulating an *agile* approach, details
may change as it progresses and extra features may be requested.

## Creating the Project

Before jumping in let's quickly set up a project by running:

```
$ mkdir cocktail-rater
$ cd cocktail-rater
```

Then add the following `composer.json`

<<[composer.json](examples/chapter-05/scenario1/composer.json)

I> ### PhpSpec Version
I>
I> You may have notice that the PHPSpec requirement is for a development
I> version. The reason for this is that there are some features which we will
I> be using which are not in the stable release, when this changes I will
I> update this accordingly.

Run composer to install the test tools:

```
$ composer install
```

Next up we can quickly configure PHPSpec to format its output as pretty by
default so that we don't need to put it on the command line every time we run
it. To do this create a file called `phpspec.yml` with the following contents:

{title="phpspec.yml", format="yaml"}
~~~~~~~~~
formatter.name: pretty
~~~~~~~~~

Finally, initialise Behat ready to start development:

```
$ behat --init
```

All done! Now we can start...

## The First Story

Let's look at the first [story](#user-stories). One thing to note is that a
story is not a specification, it's intentionally vague and it's purpose is to
exist as a *request for conversation*. When it is time to implement a story the
team (which includes the customer) should discuss the story and decide on the
details, this will result in the generation of the acceptance tests. For the
purpose of this book I'll provide the story and tests as though this conversation
has already taken place. So, here's the story card for the first feature:

> A visitor can view a list of recipes
>
> * Displays an empty list if there are no recipes
> * Recipes display the *name of the cocktail*, *the rating* and the *name of 
> the user who submitted it*
> * The list should be presented it *decending* order of rating

From this information we can add the following feature to the project:

<<[features/visitors-can-list-recipes.feature](examples/chapter-05/scenario1/features/visitors-can-list-recipes.feature)

If you try to run Behat with this feature it will say that the context has missing
steps, to add the required snippets run:

```
$Â behat --append-snippets
```

Now we can start working to get these *scenarios* to pass.

## Application Structure

Before jumping straight into writing code let's just take a small moment to
take a look at the structure we plan to use to build the application.

![Proposed Application Structure](images/05-application-structure.png)

The core part of the application will be the *domain model*, this will consist
of our modelled interpretation of the business rules. It will have no knowledge
of how or where the data in stored, the user interface or any non-business related
implementation details. To achieve this level of separation we'll use *inversion
of control* to let the other layers *plug in* to the domain layer.

Behind the *domain model* there will be storage implementation layer for our
chosen storage system. The storage system has not yet been decided so we'll
make use of SQLite until we decide. The reason of this choice is that SQLite
allows the access of a database file without needing to set up a database
server and it's easier to use that writing our own file based storage system.

In chapter 3 I introduced [CQRS](#cqrs) and stated that while we are not going
to implement it in our application we will make a distinction between *command*
and *query* interactions with the application. Therefore, in front of the *domain
model* we'll have a layer of *commands* and *queries*, all interactions with
the *domain model* from the *GUI* will go through these.

Finally, we'll have the GUI website. We'll start of just mocking this up with
some basic HTML but as our application becomes more complete we can make use
of a modern MVC[^mvc] framework. Again we won't worry about which one until
later on.

[^mvc]: The [Model View Controller](http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) design pattern.

## Scenario: View an empty list of recipes

So here's the scenario which we want to get to pass:

{title="View an empty list of recipes", lang="cucumber"}
~~~~~~~~
    Scenario: View an empty list of recipes
        Given there are no recipes
        When I request a list of recipes
        Then I should see an empty list
~~~~~~~~

We're going to use TDD to work from the *outside in*. What I mean be this is
rather than trying to build the model and then get it to do what we need it
to do, we'll start with what we want it to do and let that help create the
model.

### Fleshing out the FeatureContext

Behat has already added the required *snippet* templates to the
`FeatureContext` so let's try to pencil in what we want to happen. Take a look
at the code I have added first then I'll explain it:

<<[features/bootstrap/FeatureContext.php](examples/chapter-05/scenario1/features/bootstrap/FeatureContext.php)

The thinking I have used here goes something like this:

> In order to list recipes we'll create a query object then somehow we'll
> process that query to get the result. This process will involve fetching
> all existing recipes and returning the result.

The first line of our test states *"Given there are no recipes"*. Now I'm going
to use the term *Respoitory* for the place where objects will be stored, so to
make this pass we've got to ensure that the *Repository* for storing recipes is
empty. I've also stated that we're not going to worry about what storage system
we will be using until later, so in the mean time I've decided to create a
simple test repository which we'll use to emulate the repository functionality.
I've decided to name this
`CocktailRater\Testing\Repository\TestRecipeRepository`.

With this information, the first thing we need to do is create an instance of
this repository. I've done this in the `FeatureContext` method called
`beforeScenario`.

W> ### The @BeforeScenario Annotation
W>
W> You may also notice that I've added `@BeforeScenario` to the
W> docblock for this method, this is known as an *annotation* and is required
W> to inform Behat to run this method before it runs each *scenario*.

Next we *clear* the repository to ensure there are no recipes in the
`thereAreNoRecipes` method.

Then next line of the test states *"When I request a list of recipes"*. For
this we create the query object, run it and store the result. I've decided that
the *running* of the query will be done by a *query handler* and therefore
we'll use the verb *handle* to run it. Also, we know that the *query handler*
will need to fetch recipes from the *repository* so we pass it to the *handler*
via the constructor. All this is put into action in the
`iRequestAListOfRecipes` method in our `FeatureContext`.

Finally, the last line of the test says *"Then I should see an empty list"*, to
do this we'll simple check the value in the query result. In order to make a
Behat snippet fail it must throw an exception. However, rather than writing our
own checking methods I've decided to make use of the *assert* methods provided
by PHPUnit. For this test we've used 2 asserts, one to check the result is an
*array* and the second to check it's empty.

At this point if you try to run Behat you'll see PHP error messages since we've
referenced classes which don't exist. To fix this lets add the classes.

### Writing the Code

The first list of the test requires the *respository* and that is has a method
called `clear`. Let's quickly add that:

{title="src/CocktailRater/Testing/Repository/TestRecipeRepoitory.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Testing\Repository;

use CocktailRater\Domain\Repository\RecipeRepository;

final class TestRecipeRepository 
{
    public function clear()
    {
    }
}
~~~~~~~~

That's nice and simple for now, you may have noticed the use of the `final`
keyword. For now I'm just going to say that I add this to my classes by
default, this is not required but is my preference, I'll explain the reason for
this a bit later on.

Next up let's create the `ListRecipesQuery`. A query class will contain the
parameters for the query, in this case there are none so the class simply looks
like this:

<<[src/CocktailRater/Application/Visitor/Query/ListRecipesQuery.php](examples/chapter-05/scenario1/src/CocktailRater/Application/Visitor/Query/ListRecipesQuery.php)

I've chosen to add `Visitor` to the namespace since these are queries which
will be made by *vistors*.

Now for the interesting bit, the `ListRecipesHandler`. From looking at the
`FeatureContext` it needs to take a *repository* as a constructor parameter,
the query as a parameter to the `handle` method and return some object which
has a `getRecipes` method.

Here we don't want to depend on our test repository so we'll create an
interface which will be used in its place. For the return value we'll create a
class called `CocktailRater\Application\Visitor\Query\ListRecipesResult`.
Without further ado, here it is:

<<[src/CocktailRater/Application/Visitor/Query/ListRecipesHandler.php](examples/chapter-05/scenario1/src/CocktailRater/Application/Visitor/Query/ListRecipesHandler.php)

At this point we've created all this classes that were referenced from the 
`FeatureContext` but this last one has just introduced 2 more: the 
`RecipeRepository` and the `ListRecipesResult` so let's add them quickly too
(this is what I was referring to when I said we'd work from the *outside in*):

<<[src/CocktailRater/Application/Visitor/Query/ListRecipesResult.php](examples/chapter-05/scenario1/src/CocktailRater/Application/Visitor/Query/ListRecipesResult.php)

<<[src/CocktailRater/Domain/Repository/RecipeRepository.php](examples/chapter-05/scenario1/src/CocktailRater/Domain/Repository/RecipeRepository.php)

The `ListRecipesResult` class simply returns the and empty list from
`getRecipes` which is all it needs to do now.

The `RecipeRepository` interface currently has no methods. This is because the
only method currently existing in out test repository is `clear`, however this
method is only relevant for the tests, there is now requirement for this in the
actual application.

Now there's only one thing left to do: the `ListRecipesHandler` class requires
a `RecipeRepository` to be provided to the constructor but, in the `FeatureContext`
we've provided a `TestRecipeRepository`. To make this work we need to make the
test repository implement the interface:

{title="src/CocktailRater/Testing/Repository/TestRecipeRepoitory.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Testing\Repository;

use CocktailRater\Domain\Repository\RecipeRepository;

final class TestRecipeRepository implements RecipeRepository
{
    public function clear()
    {
    }
}
~~~~~~~~

At this point should be able to run Behat by executing:

{lang="text"}
~~~~~~~~
$ behat
~~~~~~~~

And see the first *scenario* pass.

## Scenario: View a list with 1 item

```
$ composer require beberlei/assert:@stable
```

## Scenario: Recipes are sorted by rating

## Some Thoughts

## What Next?
