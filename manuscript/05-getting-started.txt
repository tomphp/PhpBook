# Getting Started

## The Application

A brief description of the application we are going to build is as follows:

> The aim is to produce a website which allows *users* of the site to
> *view* and *rate* cocktail recipes submitted by other users, they can also 
> *submit their own*.
>
> Any *visitors* to the site can view the list of recipes *sorted by
> rating*, but they must *register* with a *username*, *email* and *password*
> in order to *rate* or *add* a *recipe*.
>
> A *recipe* consists of the *cocktail name*, the *method* and the list of *measured
> ingredients* consisting of the *ingredient* and *amount*. It also must keep
> track of the *user* who submitted it.
> 
> Ratings will be *star* ratings with *users* being able to *rate* a recipe
> with 1 to 5 *stars*.
> 
> *Quantities* can be entered as either *millilitres (ml)*, *fluid ounces (fl
> oz)*, *teaspoons (tsp)* or just a number.
> 
> The cocktail ingredients available are limited to a selection which can only
> be added to by an *administrator*.

Now we've got a basic understanding of the application we are going to build let's
take a quick look at the list of [user stories](#user-stories). These are
listed in order of priority.

* A visitor can view a list of recipes
* A visitor can view a recipe
* A visitor can register and become a user
* A visitor can login to become a user
* A user can rate a recipe
* A user can add a recipe
* An administrator can add an ingredient

We will proceed to implement each of these stories in order. This may seem like
a very basic application but it will provide enough functionality to give a
good example of how to start building a well designed, extensible application.
Also, because this is being developed by emulating an *agile* approach, details
may change as it progresses and extra features may be requested.

## Creating the Project

Before jumping in let's quickly set up a project. First create a directory
for the project:

{lang="console"}
~~~~~~~~
$ mkdir cocktail-rater
$ cd cocktail-rater
~~~~~~~~

Then add the following `composer.json`

<<[composer.json](examples/chapter-05/scenario1/composer.json)

I> ### PHPSpec Version
I>
I> You may have noticed that the PHPSpec requirement is for a development
I> version. The reason for this is that there are some features which we will
I> be using which are not in the stable release yet. When this changes I will
I> update the book.

Now run Composer to install the test tools:

{lang="console"}
~~~~~~~~
$ composer install
~~~~~~~~

Next up we can quickly configure PHPSpec to format its output using the
*pretty* formatter by default so that we don't need to put it on the command
line every time we run it. To do this create a file called `phpspec.yml` with
the following contents:

{title="phpspec.yml", format="yaml"}
~~~~~~~~
formatter.name: pretty
~~~~~~~~

Finally, initialise Behat ready to start development:

{lang="console"}
~~~~~~~~
$ behat --init
~~~~~~~~

All done! Now we can start...

## The First Story

Let's look at the first [story](#user-stories). Here's the story card:

> A visitor can view a list of recipes
>
> * Displays an empty list if there are no recipes
> * Recipes display the *name of the cocktail*, *the rating* and the *name of 
> the user who submitted it*
> * The list should be presented in *descending* order of *rating*

From this information we can add the following feature file to the project:

<<[features/visitors-can-list-recipes.feature](examples/chapter-05/scenario1/features/visitors-can-list-recipes.feature)

If you try to run Behat with this feature it will say that the context has
missing steps, to add the required snippets run:

{lang="console"}
~~~~~~~~
$Â behat --append-snippets
~~~~~~~~

Now we can start working to get these *scenarios* to pass.

## Application Structure

Before jumping straight into writing code let's just take a small moment to
take a look at the structure we plan to use to build the application.

![Proposed Application Structure](images/05-application-structure.png)

The core part of the application will be the *domain model*, this will consist
of our modelled interpretation of the business rules. It will have no knowledge
of how or where the data is stored, the user interface or any non-business
related implementation details. To achieve this level of separation we'll use
*inversion of control* to let the other layers *plug in* to the domain layer.

Behind the *domain model* there will be a storage implementation layer for our
chosen storage system. The storage system has not yet been decided so we'll
make use of SQLite until we decide. The reason for this choice is that SQLite
allows the use of a database file without needing to set up a database server
and it's easier to use than writing our own file-based storage system.

In chapter 3 I introduced [CQRS](#cqrs) and stated that while we are not going
to implement it in our application we will make a distinction between *command*
and *query* interactions within the application. Therefore, in front of the
*domain model* we'll have a layer of *commands* and *queries*, all interactions
with the *domain model* from the *GUI* will go through these.

Finally, we'll have the GUI website. We'll start off by mocking this up with
some basic HTML but as our application becomes more complete we can make use of
a modern MVC[^mvc] framework. Again we won't worry about which one until later
on.

[^mvc]: The [Model View Controller](http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) design pattern.

## Scenario: View an empty list of recipes

Let's start off by getting the first scenario to pass, as a quick reminder here
it is:

{title="View an empty list of recipes", lang="cucumber"}
~~~~~~~~
    Scenario: View an empty list of recipes
        Given there are no recipes
        When I request a list of recipes
        Then I should see an empty list
~~~~~~~~

We're going to use TDD to create our code from the *outside in*. What I mean by
this is rather than trying to build the model and then get it to do what we
need it to do, we'll start with what we want it to do and let that help create
the model.

### Fleshing out the FeatureContext

Behat has already added the required *snippet* templates to the
`FeatureContext` so let's try to pencil in what we want to happen. Take a look
at the code I have added first then I'll explain it:

<<[features/bootstrap/FeatureContext.php](examples/chapter-05/scenario1/features/bootstrap/FeatureContext.php)

The thinking I have used here goes something like this:

> In order to list recipes we'll create a query object then somehow we'll
> process that query to get the result. This process will involve fetching
> all existing recipes and returning the result.

The first line of our test states *"Given there are no recipes"*. I'm going
to use the *Repository* design pattern for the storing of objects, so to
make this pass we've got to ensure that the *Repository* for storing recipes is
empty. I've also stated that we're not going to worry about what storage system
we will be using until later, so in the mean time I've decided to create a
simple test repository which we'll use to emulate the repository functionality.
I've decided to name this
`CocktailRater\Testing\Repository\TestRecipeRepository`.

With this information, the first thing we need to do is create an instance of
this repository. I've done this in the `beforeScenario` method in the
`FeatureContext`.

W> ### Annotations
W>
W> You may also notice that I've added `@BeforeScenario` to the
W> docblock for this method, this is known as an *annotation* and is required
W> to inform Behat to run this method before it runs each *scenario*.
W>
W> Annotation strings in the docblock start with the `@` symbol. Behat
W> uses annotations for several things, you will see that each snippet function
W> has a `@Given`, `@When` or `@Then` annotation, again this is not just a
W> comment but is actually required by Behat in order to work.

Next we *clear* the repository to ensure there are no recipes in the
`thereAreNoRecipes` method.

Then next line of the test states *"When I request a list of recipes"*. For
this we create the query object, run it and store the result. I've decided that
the *running* of the query will be done by a *query handler* and therefore
we'll use the verb *handle* to run it. Also, we know that the *query handler*
will need to fetch recipes from the *repository* so we pass this to the
*handler* via the constructor. All this is put into action in the
`iRequestAListOfRecipes` method in the `FeatureContext`.

Finally, the last line of the test says *"Then I should see an empty list"*, to
do this we'll simple check the value in the query result. In order to make a
Behat snippet fail it must throw an exception. However, rather than writing our
own checking methods I've decided to make use of the *assert* methods provided
by PHPUnit. For this test we've used 2 asserts, one to check the result is an
*array* and the second to check it's empty.

At this point if you try to run Behat you'll see PHP error messages saying we've
referenced classes which don't exist, to fix this lets add the classes.

### Writing the Code

The first line of the test requires the *repository* and that it has a method
called `clear` so to start with let's create that:

{title="src/CocktailRater/Testing/Repository/TestRecipeRepository.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Testing\Repository;

use CocktailRater\Domain\Repository\RecipeRepository;

final class TestRecipeRepository 
{
    public function clear()
    {
    }
}
~~~~~~~~

You may have noticed the use of the `final` keyword. For now I'm just going to
say that I add this to my classes by default, this is not required but is my
preference, I'll explain the reason for this [a bit later on](#final-keyword).

Next up let's create the `ListRecipesQuery`. A query class will contain the
parameters for the query, in this case there are none so the class simply looks
like this:

<<[src/CocktailRater/Application/Visitor/Query/ListRecipesQuery.php](examples/chapter-05/scenario1/src/CocktailRater/Application/Visitor/Query/ListRecipesQuery.php)

I've chosen to add `Visitor` to the namespace since these are queries which
will be made by *visitors*.

Now for the interesting bit, the `ListRecipesHandler`. From looking at the
`FeatureContext` it needs to take a *repository* as a constructor parameter,
the *query* as a parameter to the `handle` method and return some object which
has a `getRecipes` method.

Here we don't want to depend on our test repository so we'll create an
*interface* which will be used in its place. For the return value we'll create
a class called `CocktailRater\Application\Visitor\Query\ListRecipesResult`.

Without further ado, here it is:

<<[src/CocktailRater/Application/Visitor/Query/ListRecipesHandler.php](examples/chapter-05/scenario1/src/CocktailRater/Application/Visitor/Query/ListRecipesHandler.php)

At this point we've created all of the classes that were referenced from the
`FeatureContext` but this last one has just introduced 2 more: the
`RecipeRepository` and the `ListRecipesResult`. Let's add them to the project
also (this is what I was referring to when I said we'd work from the *outside
in*):

<<[src/CocktailRater/Application/Visitor/Query/ListRecipesResult.php](examples/chapter-05/scenario1/src/CocktailRater/Application/Visitor/Query/ListRecipesResult.php)

<<[src/CocktailRater/Domain/Repository/RecipeRepository.php](examples/chapter-05/scenario1/src/CocktailRater/Domain/Repository/RecipeRepository.php)

The `ListRecipesResult` class simply returns an empty list from
`getRecipes`, this is all it needs to do for now.

The `RecipeRepository` interface currently has no methods. This is because the
only method currently existing in our test repository is `clear`, however this
method is only relevant for the tests, there is no requirement for this in the
actual application.

Now there's only one thing left to do: the `ListRecipesHandler` class requires
a `RecipeRepository` to be provided to the constructor but, in the
`FeatureContext` we've provided a `TestRecipeRepository`. To make this work we
need to make the test repository implement the interface:

{title="src/CocktailRater/Testing/Repository/TestRecipeRepository.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Testing\Repository;

use CocktailRater\Domain\Repository\RecipeRepository;

// leanpub-start-insert
final class TestRecipeRepository implements RecipeRepository
// leanpub-end-insert
{
    public function clear()
    {
    }
}
~~~~~~~~

At this point we should be able to run Behat and see the first *scenario* pass:

{lang="console"}
~~~~~~~~
$ behat
~~~~~~~~

## Scenario: View a list with 1 recipe

We got the first scenario to pass without any real logic, to get the next one
to pass we need to start filling in some of the blanks that we created.

### Updating the FeatureContext

Just like last time we can start by adding some content to our 2 remaining
methods in the `FeatureContext`. Here I'd just like to point out that you may
find it easier to work with one at a time, but for the sake of not making this
book too long I'm condensing the processes down a bit.

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
<?php

use Behat\Behat\Context\SnippetAcceptingContext;
use Behat\Behat\Tester\Exception\PendingException;
use Behat\Gherkin\Node\PyStringNode;
use Behat\Gherkin\Node\TableNode;
use CocktailRater\Application\Visitor\Query\ListRecipes;
use CocktailRater\Application\Visitor\Query\ListRecipesHandler;
use CocktailRater\Application\Visitor\Query\ListRecipesQuery;
use CocktailRater\Application\Visitor\Query\ListRecipesQueryHandler;
// leanpub-start-insert
use CocktailRater\Domain\CocktailName;
use CocktailRater\Domain\Rating;
use CocktailRater\Domain\Recipe;
use CocktailRater\Domain\User;
use CocktailRater\Domain\Username;
// leanpub-end-insert
use CocktailRater\Testing\Repository\TestRecipeRepository;
use PHPUnit_Framework_Assert as Assert;

/**
 * Behat context class.
 */
class FeatureContext implements SnippetAcceptingContext
{
    // ...

    /**
     * @Given there's a recipe for :name by user :user with :rating stars
     */
    public function theresARecipeForByUserWithStars($name, $user, $rating)
    {
        // leanpub-start-insert
        $this->recipeRepository->store(
            new Recipe(
                new CocktailName($name),
                new Rating($rating),
                new User(new Username($user))
            )
        );
        // leanpub-end-insert
    }

    /**
     * @Then I should see a list of recipes containing:
     */
    public function iShouldSeeAListOfRecipesContaining(TableNode $table)
    {
        // leanpub-start-insert
        $callback = function ($recipe) {
            return [
                (string) $recipe['name'],
                (float) $recipe['rating'],
                (string) $recipe['user']
            ];
        };

        Assert::assertEquals(
            array_map($callback, $this->result->getRecipes()),
            array_map($callback, $table->getHash())
        );
        // leanpub-end-insert
    }
}
~~~~~~~~

In `theresARecipeForByUserWithStars` we're creating a new `Recipe` object. The
`Recipe` needs a name, rating and user so we can add what we think look like
sensible dependencies via the constructor. We also *store* this new object in
the repository.

In the `iShouldSeeAListOfRecipesContaining` method we compare the results
returned from the query with the table of expected results using PHPUnit's
`assertEquals`. I've also used `array_map` to ensure both arrays contain the
same types since all values in Behat tables are strings.

### Adding new Classes to the Model

I> ### Unit Tests
I>
I> Before continuing I'd just like to point out that up until this point I've
I> not created any unit tests. From this point on I'll be using them for all
I> development in the *domain model*. However, I won't be showing them or the
I> process as it would take up too many pages but they're all available in the
I> example code for the book if you want to study them.

Let's start off by adding the new classes to the model:

{title="src/CocktailRater/Domain/Recipe.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Domain;

final class Recipe
{
    /** @param string $name */
    public function __construct(CocktailName $name, Rating $rating, User $user)
    {
    }
}
~~~~~~~~

{title="src/CocktailRater/Domain/CocktailName.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Domain;

final class CocktailName
{
    /** @var string $value */
    public function __construct($value)
    {
    }
}
~~~~~~~~

{title="src/CocktailRater/Domain/Rating.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Domain;

final class Rating
{
    /** @var float $value */
    public function __construct($value)
    {
    }
}
~~~~~~~~

{title="src/CocktailRater/Domain/User.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Domain;

final class User
{
    /** @var string $username */
    public function __construct(Username $username)
    {
    }
}
~~~~~~~~

{title="src/CocktailRater/Domain/Username.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Domain;

final class Username
{
    /** @param string $value */
    public function __construct($value)
    {
    }
}
~~~~~~~~

We also need to add the `store` method to the repository interface:

{title="src/CocktailRater/Domain/Repository/RecipeRepository.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Domain\Repository;

// leanpub-start-insert
use CocktailRater\Domain\Recipe;
// leanpub-end-insert

interface RecipeRepository
{
    // leanpub-start-insert
    public function store(Recipe $recipe);
    // leanpub-end-insert
}
~~~~~~~~

This also means we need to add the method to the `TestRecipeRepository`:

{title="src/CocktailRater/Testing/Repository/TestRecipeRepository.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Testing\Repository;

// leanpub-start-insert
use CocktailRater\Domain\Recipe;
// leanpub-end-insert
use CocktailRater\Domain\Repository\RecipeRepository;

final class TestRecipeRepository implements RecipeRepository
{
    // leanpub-start-insert
    public function store(Recipe $recipe)
    {
    }
    // leanpub-end-insert

    public function clear()
    {
    }
}
~~~~~~~~

### Making the Scenario Pass

At this point only the last line of the scenario should be failing. We've got
the template of the model laid out so we just need to fill in the details. To
start with let's take a look at how the query handler will work:

<<[src/CocktailRater/Domain/Repository/RecipeRepository.php](examples/chapter-05/scenario2/src/CocktailRater/Domain/Repository/RecipeRepository.php)

It's quite simple, it fetches all recipes from the repository, adds the details
of each one to the result object and returns it. This does however mean we've
got a bit of work to do to get it all working. First up let's update the
classes in the *domain model*:

<<[src/CocktailRater/Domain/Recipe.php](examples/chapter-05/scenario2/src/CocktailRater/Domain/Recipe.php)

<<[src/CocktailRater/Domain/CocktailName.php](examples/chapter-05/scenario2/src/CocktailRater/Domain/CocktailName.php)

<<[src/CocktailRater/Domain/Rating.php](examples/chapter-05/scenario2/src/CocktailRater/Domain/Rating.php)

<<[src/CocktailRater/Domain/User.php](examples/chapter-05/scenario2/src/CocktailRater/Domain/User.php)

<<[src/CocktailRater/Domain/Username.php](examples/chapter-05/scenario2/src/CocktailRater/Domain/Username.php)

In the *domain model* we've started to make use of Benjamin Eberlei's
*[Assert](https://github.com/beberlei/assert)* library. To do this we need to
install the dependency with Composer by running:

{lang="console"}
~~~~~~~~
$ composer require beberlei/assert:@stable
~~~~~~~~

W> ### Using 3rd Party Libraries in the Domain Model
W>
W> Adding a dependency to a 3rd party library is something that should not be
W> done without serious consideration. A better approach is to use *Inversion
W> of Control* to make the model depend on the library via a layer of
W> abstraction. The [Adapter](http://en.wikipedia.org/wiki/Adapter_pattern)
W> design pattern is a very good tool for this job.
W>
W> So, with that said, why am I using the Assert library from within the domain
W> model? The reason is: firstly it's a well-used and stable library with
W> utility methods which have no side effects. Secondly, and more importantly,
W> I'm using it in a way which adds, what I think, is a missing feature in the
W> PHP language; namely typehints for scalar types and arrays.
W>
W> There is an interesting discussion with Mathais Verraes on the [DDDinPHP
W> Google Group](https://groups.google.com/forum/#!msg/dddinphp/YGogT1NSbO0/u22c4dgoxdEJ)
W> about adding dependencies to 3rd party libraries to your domain model. The
W> bottom line though is, before doing this you should exercise extreme
W> consideration of what you are about to do.

One thing which may have caught your eye in the `User` class is the
`fromValues` *static* method. This is known as a *named constructor*, its a way
in which we can provide alternate constructors for classes and is one of the
few valid uses of the `static` keyword. Since it maintains no state and works
in a purely *functional* way it is a safe use of `static`. At this point in time
this has only been used in the unit tests but the neater tests I felt were a
good enough reason to add it.

Another thing we have done here is restrict the value allowed for a rating to
be between 1 and 5. If it falls outside of this range we throw an exception.
The appropriate exception to be throw here is PHP SPL's `OutOfBoundsException`.
However, rather than throw it directly we've extended it so that it can be
tracked down as coming from our application. Let's take a quick look at it:

<<[src/CocktailRater/Domain/Exception/OutOfBoundsException.php](examples/chapter-05/scenario2/src/CocktailRater/Domain/Exception/OutOfBoundsException.php)

Again you'll notice the use of a *named constructor*, I think this is a really
neat way to keep the exception messages neat and tidy and in a relevant place.

Next let's quickly update the `ListRecipesResult` class:

<<[src/CocktailRater/Application/Visitor/Query/ListRecipesResult.php](examples/chapter-05/scenario2/src/CocktailRater/Application/Visitor/Query/ListRecipesResult.php)

Finally, we need to update the functionality of the repository to return the
list of recipes stored:

<<[src/CocktailRater/Domain/Repository/RecipeRepository.php](examples/chapter-05/scenario2/src/CocktailRater/Domain/Repository/RecipeRepository.php)

<<[src/CocktailRater/Testing/Repository/TestRecipeRepository.php](examples/chapter-05/scenario2/src/CocktailRater/Testing/Repository/TestRecipeRepository.php)

As you can see, we've created an in-memory test repository. This is good enough
for what we need so far.

You can now run Behat and watch the second scenario pass.

## Scenario: Recipes are sorted by rating

You may have already noticed that when you run Behat now most of our final
scenario already passes, the only thing which fails is the order in which
the recipes are listed. To fix this we can go straight into the 
`ListRecipesHandler` and sort the recipes there:

<<[src/CocktailRater/Application/Visitor/Query/ListRecipesHandler.php](examples/chapter-05/scenario3/src/CocktailRater/Application/Visitor/Query/ListRecipesHandler.php)

We also need to add new methods to both the `Recipe` and `Rating` classes:

{title="src/CocktailRater/Domain/Recipe.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Domain;

use Assert\Assertion;

final class Recipe
{
    // ...

    // leanpub-start-insert
    /** @return bool */
    public function isHigherRatedThan(Recipe $other)
    {
        return $this->rating->isHigherThan($other->rating);
    }
    // leanpub-end-insert
}
~~~~~~~~

{title="src/CocktailRater/Domain/Rating.php", lang="php"}
~~~~~~~~
<?php

namespace CocktailRater\Domain;

use Assert\Assertion;
use CocktailRater\Domain\Exception\OutOfBoundsException;

final class Rating
{
    // ...

    /** @return bool */
    public function isHigherThan(Rating $other)
    {
        return $this->value > $other->value;
    }
}
~~~~~~~~

That's it, the first feature is done!

## Tidying Up

Now the feature is complete let's take a little look and see if there's
anything we can do to make the code a bit better.

The main thing which needs to be improved here is chaining of methods in the
*query handler*.  We have created have ugly lines of code like this:

~~~~~~~~
$recipe->getUser()->getUsername()->getValue()
~~~~~~~~

Big chains of method calls like this violate the [Law of
Demeter](http://en.wikipedia.org/wiki/Law_of_Demeter) which states *you should
only talk to your immediate friends*. What this means is you can **only** call
methods and access properties only of objects which are properties of the
current class, which are parameters to the current method, or have been created
inside the method. This law is pretty much stating the same thing as the
*one dot per line* rule of [Object Calisthenics](#object-calisthenics). Note
that PHP request the use of `$this->` to methods and properties so it's actual
*two arrows per line*.

So how to solve it? Well on approach might be to ask the top level class
(*aggregate*) to ask the next level down to return the value and so on like so:

~~~~~~~~
class Recipe
{
    // ...

    public function getUsername()
    {
        return $this->user->getUsernameValue();
    }
}

class User
{
    // ...

    public function getUsernameValue()
    {
        return $this->username->getValue();
    }
}
~~~~~~~~

However, if you're going to do this for more that 2 or 3 values the interface
is going to start to get pretty bloated. Another way might be to add a method
to the `Recipe` class to return all it's values as an array or *Data Transfer
Object*. There are other ways you could do this but for this project let's use
a combination of these 2 methods. If only 1 or 2 getters are required we'll
consider using them, otherwise well use a *read* method to return a DTO (I
prefer objects to arrays because the content is defined and it can be immutable
- even though it's extra code. However, using an array or object with public
properties might be appropriate for your project).

### Exposing Recipe Values

With this in mind, let's expose the contents of the `Recipe` class via a DTO.
We do this by creating 2 DTO classes, one for `Recipe` and one for `User`:

<<[src/CocktailRater/Domain/RecipeDetails.php](examples/chapter-05/scenario3-tidied/src/CocktailRater/Domain/RecipeDetails.php)

<<[src/CocktailRater/Domain/UserDetails.php](examples/chapter-05/scenario3-tidied/src/CocktailRater/Domain/UserDetails.php)

And add the following method to `User` and `Recipe`:

{title="CocktailRater/Domain/Recipe.php", lang="php"}
~~~~~~~~
    /** @return RecipeDetails */
    public function getDetails()
    {
        return new RecipeDetails(
            $this->name
            $this->user->getDetails(),
            $this->rating
        );
    }
~~~~~~~~

{title="CocktailRater/Domain/User.php", lang="php"}
~~~~~~~~
    /** @return UserDetails */
    public function getDetails()
    {
        return new UserDetails($this->username);
    }
~~~~~~~~

Then we can update our query handler to use these like so:

{title="CocktailRater/Application/Visitor/ListRecipesHandler.php", lang="php"}
~~~~~~~~
    /** @return ListRecipesResult */
    public function handle(ListRecipesQuery $query)
    {
        $result = new ListRecipesResult();

        foreach ($this->getAllRecipesSortedByRating() as $recipe) {
            // leanpub-start-insert
            $details = $recipe->getDetails();
            // leanpub-end-insert

            $result->addRecipe(
                $details->getName(),
                $details->getRating(),
                $details->getUsername()
            );
        }

        return $result;
    }
~~~~~~~~

At this point we can also remove `getUsername` from the `User` class and
`getName`, `getRating` and `getUser` from the `Recipe` class.

Already this is looking a whole lot neater but we're still violating the *law
of demeter* at 2 levels in the *handler*. Firstly, we're calling `getDetails`
on a `Recipe` objects which are not a *immediate friends* of the handler (since
they fetched from a repository). Secondly, we're calling the *get* methods on
the details object returned from the `Recipe` objects. Considering this is
happening just at the application layer in our handler classes I don't really
think this is the biggest crime and could be left as it is. That said, let's
still try and tidy it up some more.

To do this let's get rid of all the calls to the *getters* on the details
objects.  We can do this by simply handing in the details DTO to the result
class constructor. The problem with this is that is adds a dependency on the
*domain model* from anywhere that a result object is used. When using a
language like Java, C++ or C# this becomes something that really needs to be
fixed as separate packages need to be able to be compiled and deployed
independently, however, PHP doesn't work like that (maybe one day it will).
Even so, it's probably still good practice to work this way, also since we
don't want any other layers which talk to the application to create *result*
objects let's make the *result* into an *interface*. Then we can have a
concrete result DTO which can know about the *details* DTO and because the
dependency from outside is on the interface only it's decoupled form the
*domain*.

Now we have this:

<<[src/CocktailRater/Application/Visitor/Query/ListRecipesResultData.php](examples/chapter-05/scenario3-tidied/src/CocktailRater/Application/Visitor/Query/ListRecipesResultData.php)

<<[src/CocktailRater/Application/Visitor/Query/ViewRecipeResultData.php](examples/chapter-05/scenario3-tidied/src/CocktailRater/Application/Visitor/Query/ViewRecipeResultData.php)

{title="CocktailRater/Application/Visitor/ListRecipesHandler.php", lang="php"}
~~~~~~~~
    /** @return ListRecipesResult */
    public function handle(ListRecipesQuery $query)
    {
        // leanpub-start-insert
        return new ListRecipesResultData(
            array_map(function (Recipe $recipe) {
                return $recipe->getDetails();
            },
            $this->getAllRecipesSortedByRating())
        );
        // leanpub-end-insert
    }
~~~~~~~~

That's almost it now, the handler is much neater but we've still not quite
conformed to the *Law of Demeter* because it still gets the recipe from the
*repository*. In most circumstances, particularly in the *domain model* I'm
very diligent about obeying the *Law of Demeter*, however, in this circumstance
I feel we've done enough. A good exercise is to consider how to obey it
completely in the handler but for for now I'm going to leave it as it is.

### Have we gone too far?

You might be thinking to yourself that this is all a bit excessive. We have an
*aggregate* which returns a DTO which is then copied into another DTO which
looks almost the same. We have an extra interface to describe the *result* DTO.
Isn't simply passing back the *details* DTO from the handler be sufficient? Or,
is that even too much and the *details* DTO is overkill and a simple
associative array would have done. You may even be thinking this looks far too
much like Java.

If you are thinking all this you are right, none of this is necessary but it
depends on the scale of the project, how many people are going to be working
with the code, the growth expectancy of the project and even the budget. What
we've done here is apply best practices and made the code as explicit and self
documented as possible and future developers and our future selves will thank
us for this.

## What Next?

So far we've managed to get the first feature's tests to pass. However, we've
done it in quite an isolated way by considering this single *query* on it's
own. In the next chapter we'll quickly add the second feature then we can
analyse the two to find similarities. We'll then use this knowledge to
*refactor* what we have into a more generic form. After that we'll try to
display the application's output on a page.
