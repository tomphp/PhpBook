# Adding the Second Feature

Let's take a look at the story card for the next feature:

> A visitor can view a recipe
>
> * Displays name, rating, user, and the method
> * Displays ingredients with quantities and units

As before I shall provide the following acceptance tests:

<<[features/visitors-can-view-a-recipe.feature](examples/chapter-06/feature2/features/visitors-can-view-a-recipe.feature)

In the last chapter I put a lot of focus on the TDD process and the way the
code evolved. Doing this for the whole book would get pretty long winded, so as
we progress I'll be doing this less and instead focusing on the specific points
and decisions made in each step.

In this chapter we want to implement the second feature which requires a very
similar process to that in the previous chapter so I'll cover it in less detail.
Once we have this done we're going to spend a bit time analysing what we have
created so far and try refactor and extract a better application structure out
of it.

## The FeatureContext

First up let's quickly append the new *snippet* templates to the feature context
by run:

{lang="console"}
~~~~~~~~
$ behat --append-snippets
~~~~~~~~

Now the feature context needs to be updated, here what I've come up with:

<<[features/bootstrap/FeatureContext.php](examples/chapter-06/feature2/features/bootstrap/FeatureContext.php)

This has got a little bit complex because we're building the `Recipe` objects
over a sequence of steps. Since the `Recipe` is takes most of it's values via
the constructor we have to store up the details until we have them all and can
create the object in `iRequestToViewRecipeFor`. Also, once a `Recipe` is stored
we save the ID. The `FeatureContext` definitely needs to be tidied up a bit but
before we look at doing that lets see the actual implementation.

## The Implementation

I'm just going to show you all the code now, there is a fair bit of it but it
should all be self explanatory. I'll explain a couple of small bits and then
well look at ways we can improve it.

<<[src/CocktailRater/Application/Visitor/Query/ViewRecipeQuery.php](examples/chapter-06/feature2/src/CocktailRater/Application/Visitor/Query/ViewRecipeQuery.php)

This time the *query* contains the *ID* of the recipe to be viewed.

<<[src/CocktailRater/Application/Visitor/Query/ViewRecipeHandler.php](examples/chapter-06/feature2/src/CocktailRater/Application/Visitor/Query/ViewRecipeHandler.php)

The *handler* makes a new request `findById` to the repository. There's also
some pretty ugly chaining of function calls to get the values. We'll do
something about that soon.

<<[src/CocktailRater/Application/Visitor/Query/ViewRecipeResult.php](examples/chapter-06/feature2/src/CocktailRater/Application/Visitor/Query/ViewRecipeResult.php)

There's nothing really special in the *result*, it's just the collection of
data.

<<[src/CocktailRater/Domain/Repository/RecipeRepository.php](examples/chapter-06/feature2/src/CocktailRater/Domain/Repository/RecipeRepository.php)

<<[src/CocktailRater/Testing/Repository/TestRecipeRepository.php](examples/chapter-06/feature2/src/CocktailRater/Testing/Repository/TestRecipeRepository.php)

The repository now has the concept of an ID, in the test repository we just
generation an incremental one and provide and extra method so the test suite
can retrieve the last one.

<<[src/CocktailRater/Domain/RecipeId.php](examples/chapter-06/feature2/src/CocktailRater/Domain/RecipeId.php)

<<[src/CocktailRater/Domain/Recipe.php](examples/chapter-06/feature2/src/CocktailRater/Domain/Recipe.php)

There has been a few new fields added to the `Recipe` class. This has lead to
a few more *value objects* being created also:

<<[src/CocktailRater/Domain/MeasuredIngredient.php](examples/chapter-06/feature2/src/CocktailRater/Domain/MeasuredIngredient.php)

<<[src/CocktailRater/Domain/Ingredient.php](examples/chapter-06/feature2/src/CocktailRater/Domain/Ingredient.php)

<<[src/CocktailRater/Domain/Amount.php](examples/chapter-06/feature2/src/CocktailRater/Domain/Amount.php)

<<[src/CocktailRater/Domain/Unit.php](examples/chapter-06/feature2/src/CocktailRater/Domain/Unit.php)

These are all pretty plain but it's worth taking a quick look a `Unit`. This is
basically how to achieve an *enumeration* in PHP. It's basically a value object
which accepts a finite set of values, each defined as a constant of the class.
You create a *unit* of millilitres like this: `new Unit(Unit::ML)`.

## The Builder Pattern

The issue I'd like to tackle is the complex building the `Recipe` in the
`FeatureContext`. I think a nice way to tidy this up a bit would be to use
the [builder design pattern](http://en.wikipedia.org/wiki/Builder_pattern).

First of all let's create a `RecipeBuilder`:

<<[src/CocktailRater/Domain/Builder/RecipeBuilder.php](examples/chapter-06/builder-pattern/src/CocktailRater/Domain/Builder/RecipeBuilder.php)

Now we can use the builder in the `FeatureContext` but adding the following
method:

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
    // leanpub-start-insert
    /**
     * @param string $name
     *
     * @return RecipeBuilder
     */
    private function getRecipeBuilder($name)
    {
        if (!isset($this->recipes[$name])) {
            $this->recipes[$name]['builder'] = new RecipeBuilder();
            $this->recipes[$name]['builder']->setName($name);
        }

        return $this->recipes[$name]['builder'];
    }
    // leanpub-end-insert
~~~~~~~~

And updating these ones:

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
    /**
     * @Given there's a recipe for :name by user :user with :rating stars
     */
    public function theresARecipeForByUserWithStars($name, $user, $rating)
    {
        // leanpub-start-insert
        $builder = $this->getRecipeBuilder($name);

        $builder->setUser(User::fromValues($user));
        $builder->setRating(new Rating($rating));
        // leanpub-end-insert
    }
~~~~~~~~

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
    /**
     * @Given the recipe for :name has method:
     */
    public function theRecipeForHasMethod($name, PyStringNode $method)
    {
        // leanpub-start-insert
        $this->getRecipeBuilder($name)->setMethod($method->getRaw());
        // leanpub-end-insert
    }
~~~~~~~~

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
    /**
     * @Given the recipe for :name has measured ingredients:
     */
    public function theRecipeForHasMeasuredIngredients($name, TableNode $ingredients)
    {
        // leanpub-start-insert
        $builder = $this->getRecipeBuilder($name);

        foreach ($ingredients->getHash() as $ingredient) {
            $builder->addIngredient(
                Amount::fromValues(
                    $ingredient['amount'],
                    $ingredient['unit']
                ),
                new Ingredient($ingredient['name'])
            );
        }
        // leanpub-end-insert
    }
~~~~~~~~

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
    private function storeRecipes()
    {
        // leanpub-start-insert
        foreach ($this->recipes as $name => &$recipeSpec) {
            $recipe = $recipeSpec['builder']->build();

            $this->recipeRepository->store($recipe);

            $recipeSpec['id'] = $this->recipeRepository
                                     ->getLastInsertId()
                                     ->getValue();
        }
        // leanpub-end-insert
    }
~~~~~~~~

I also added this named constructor to `Amount` to make things a little bit
tidier:

{title="src/CocktailRater/Domain/Amount.php", lang="php"}
~~~~~~~~
    /**
     * @param float  $value
     * @param string $unit
     *
     * @return Amount
     */
    public static function fromValues($value, $unit)
    {
        return new self($value, new Unit($unit));
    }
~~~~~~~~

Even though we have only done this for the benefit of the `FeatureContext` it
could definitely be useful later on.

## The Ingredients Collection

## Forgotten Types

## DRY - Don't Repeat Yourself

DRY is a simple software principle which I've not mentioned yet and the name
pretty much sums it up. Applying DRY simply means if you find yourself typing
the same piece of code more than once, then extract it out into a
function, method, class or anything else which may be appropriate.

I've already applied this principle in some places, for example the
`getResultField` method in the `FeatureContext`. However, let's find another
place to apply it.

We've definitely got some repetition in some of the exception
class, take a look at these:

todo ... exception code.

To tidy this up let's use one of PHP's newer features, *traits*:

I> ### Traits
I>
I> PHP recently introduced `traits`. These are a way to include common bits
I> of code into multiple classes, almost in a copy & paste style. Traits in
I> PHP should be used to remove the repetition of small bit of code rather
I> than performing complex tasks, they should be extracted to dedicated
I> classes.
I>
I> You define the *methods* and *properties* in your `trait`, you can then use
I> those methods and properties in any class by including `use TraitName;` in
I> the body of the class.

todo ... tidy exceptions code.

D> ## Exception Messages
D>
D> Since we've put all this effort into creating nice exception message let's
D> quickly talk about them. Exception messages should not be designed to
D> display to the users of the application, they should be caught before they
D> get to the UI, logged, then a user friendly message displayed on screen.
D> The exception messages are for the developers, they are logged so problems
D> and bugs can be tracked down. Therfore, make your exception messages contain
D> as much context as necessary to understand the context.
D>
D> ### Example
D>
D> A *user* is logged in and tries to view their *recipe* but it's not found. A
D> reasonable message to display to the user might be:
D>
D> *"A recipe with ID '123' was not found."*
D>
D> But is this a good exception message? Not really as there's some missing
D> context here, they user know's who they are but to someone reading that
D> message in a log it is unclear. A better message might say:
D>
D> *"A recipe with ID '123' could not be found for user with ID '456'."*
D>
D> This is much more helpful.

Things:
* REMOVE ID FROM ACCEPTANCE TEST
* DRY and exception traits
* Problems in Feature Context
* Builder pattern
* Too many getters
* LoD and possible solutions - ISP/Extracted Object/Presenter


## Some Thoughts

Lots of test refactoring.
