# Adding the Second Feature

Let's take a look at the story card for the next feature:

> A visitor can view a recipe
>
> * Displays name, rating, user, and the method
> * Displays ingredients with quantities and units

As before I shall provide the following acceptance tests:

<<[features/visitors-can-view-a-recipe.feature](examples/chapter-06/feature2/features/visitors-can-view-a-recipe.feature)

In the last chapter I put a lot of focus on the TDD process and the way the
code evolved. Doing this for the whole book would get pretty long winded, so as
we progress I'll be doing this less and instead focusing on the specific points
and decisions made in each step.

In this chapter we want to implement the second feature which requires a very
similar process to that in the previous chapter so I'll cover it in less detail.
Once we have this done we're going to spend a bit time analysing what we have
created so far and try refactor and extract a better application structure out
of it.

## The FeatureContext

First up let's quickly append the new *snippet* templates to the feature context
by run:

{lang="console"}
~~~~~~~~
$ behat --append-snippets
~~~~~~~~

Now the feature context needs to be updated, here what I've come up with:

<<[features/bootstrap/FeatureContext.php](examples/chapter-06/feature2/features/bootstrap/FeatureContext.php)

This has got a little bit complex because we're building the `Recipe` objects
over a sequence of steps. Since the `Recipe` is takes most of it's values via
the constructor we have to store up the details until we have them all and can
create the object in `iRequestToViewRecipeFor`. Also, once a `Recipe` is stored
we save the ID. The `FeatureContext` definitely needs to be tidied up a bit but
before we look at doing that lets see the actual implementation.

## The Implementation

I'm just going to show you all the code now, there is a fair bit of it but it
should all be self explanatory. I'll explain a couple of small bits and then
well look at ways we can improve it.

<<[src/CocktailRater/Application/Visitor/Query/ViewRecipeQuery.php](examples/chapter-06/feature2/src/CocktailRater/Application/Visitor/Query/ViewRecipeQuery.php)

This time the *query* contains the *ID* of the recipe to be viewed.

<<[src/CocktailRater/Application/Visitor/Query/ViewRecipeHandler.php](examples/chapter-06/feature2/src/CocktailRater/Application/Visitor/Query/ViewRecipeHandler.php)

The *handler* makes a new request `findById` to the repository. There's also
some pretty ugly chaining of function calls to get the values. We'll do
something about that soon.

<<[src/CocktailRater/Application/Visitor/Query/ViewRecipeResult.php](examples/chapter-06/feature2/src/CocktailRater/Application/Visitor/Query/ViewRecipeResult.php)

There's nothing really special in the *result*, it's just the collection of
data.

<<[src/CocktailRater/Domain/Repository/RecipeRepository.php](examples/chapter-06/feature2/src/CocktailRater/Domain/Repository/RecipeRepository.php)

<<[src/CocktailRater/Testing/Repository/TestRecipeRepository.php](examples/chapter-06/feature2/src/CocktailRater/Testing/Repository/TestRecipeRepository.php)

The repository now has the concept of an ID, in the test repository we just
generation an incremental one and provide and extra method so the test suite
can retrieve the last one.

<<[src/CocktailRater/Domain/RecipeId.php](examples/chapter-06/feature2/src/CocktailRater/Domain/RecipeId.php)

<<[src/CocktailRater/Domain/Recipe.php](examples/chapter-06/feature2/src/CocktailRater/Domain/Recipe.php)

There has been a few new fields added to the `Recipe` class. This has lead to
a few more *value objects* being created also:

<<[src/CocktailRater/Domain/MeasuredIngredient.php](examples/chapter-06/feature2/src/CocktailRater/Domain/MeasuredIngredient.php)

<<[src/CocktailRater/Domain/Ingredient.php](examples/chapter-06/feature2/src/CocktailRater/Domain/Ingredient.php)

<<[src/CocktailRater/Domain/Amount.php](examples/chapter-06/feature2/src/CocktailRater/Domain/Amount.php)

<<[src/CocktailRater/Domain/Unit.php](examples/chapter-06/feature2/src/CocktailRater/Domain/Unit.php)

These are all pretty plain but it's worth taking a quick look a `Unit`. This is
basically how to achieve an *enumeration* in PHP. It's basically a value object
which accepts a finite set of values, each defined as a constant of the class.
You create a *unit* of millilitres like this: `new Unit(Unit::ML)`.

## The Builder Pattern

The issue I'd like to tackle is the complex building the `Recipe` in the
`FeatureContext`. I think a nice way to tidy this up a bit would be to use
the [builder design pattern](http://en.wikipedia.org/wiki/Builder_pattern).

First of all let's create a `RecipeBuilder`:

<<[src/CocktailRater/Domain/Builder/RecipeBuilder.php](examples/chapter-06/builder-pattern/src/CocktailRater/Domain/Builder/RecipeBuilder.php)

Now we can use the builder in the `FeatureContext` but adding the following
method:

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
    // leanpub-start-insert
    /**
     * @param string $name
     *
     * @return RecipeBuilder
     */
    private function getRecipeBuilder($name)
    {
        if (!isset($this->recipes[$name])) {
            $this->recipes[$name]['builder'] = new RecipeBuilder();
            $this->recipes[$name]['builder']->setName($name);
        }

        return $this->recipes[$name]['builder'];
    }
    // leanpub-end-insert
~~~~~~~~

And updating these ones:

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
    /**
     * @Given there's a recipe for :name by user :user with :rating stars
     */
    public function theresARecipeForByUserWithStars($name, $user, $rating)
    {
        // leanpub-start-insert
        $builder = $this->getRecipeBuilder($name);

        $builder->setUser(User::fromValues($user));
        $builder->setRating(new Rating($rating));
        // leanpub-end-insert
    }
~~~~~~~~

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
    /**
     * @Given the recipe for :name has method:
     */
    public function theRecipeForHasMethod($name, PyStringNode $method)
    {
        // leanpub-start-insert
        $this->getRecipeBuilder($name)->setMethod($method->getRaw());
        // leanpub-end-insert
    }
~~~~~~~~

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
    /**
     * @Given the recipe for :name has measured ingredients:
     */
    public function theRecipeForHasMeasuredIngredients($name, TableNode $ingredients)
    {
        // leanpub-start-insert
        $builder = $this->getRecipeBuilder($name);

        foreach ($ingredients->getHash() as $ingredient) {
            $builder->addIngredient(
                Amount::fromValues(
                    $ingredient['amount'],
                    $ingredient['unit']
                ),
                new Ingredient($ingredient['name'])
            );
        }
        // leanpub-end-insert
    }
~~~~~~~~

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
    private function storeRecipes()
    {
        // leanpub-start-insert
        foreach ($this->recipes as $name => &$recipeSpec) {
            $recipe = $recipeSpec['builder']->build();

            $this->recipeRepository->store($recipe);

            $recipeSpec['id'] = $this->recipeRepository
                                     ->getLastInsertId()
                                     ->getValue();
        }
        // leanpub-end-insert
    }
~~~~~~~~

I also added this named constructor to `Amount` to make things a little bit
tidier:

{title="src/CocktailRater/Domain/Amount.php", lang="php"}
~~~~~~~~
    /**
     * @param float  $value
     * @oaram string $unit
     *
     * @return Amount
     */
    public static function fromValues($value, $unit)
    {
        return new self($value, new Unit($unit));
    }
~~~~~~~~

Even though we have only done this for the benefit of the `FeatureContext` it
could definitely be useful later on.

## The Law of Demeter

Next up, let's look at tidying up some code in the *query handlers*. Both of
ones we have created have ugly lines of code like this:

~~~~~~~~
$recipe->getUser()->getUsername()->getValue()
~~~~~~~~

The `ViewRecipe` handler also has the particularly ugly `array_map` to get the
list of ingredients.

Big chains of method calls like this violate the [Law of
Demeter](http://en.wikipedia.org/wiki/Law_of_Demeter) which states *you should
only talk to your immediate friends*. What this means is you can **only** call
methods and access properties only of objects which are properties of the
current class, which are parameters to the current method, or have been created
inside the method. This law is pretty much stating the same thing as the
*one dot per line* rule of [Object Calisthenics](#object-calisthenics). Note
that PHP request the use of `$this->` to methods and properties so it's actual
*two arrows per line*.

So how to solve it? Well on approach might be to ask the top level class
(*aggregate*) to ask the next level down to return the value and so on like so:

~~~~~~~~
class Recipe
{
    // ...

    public function getUsername()
    {
        return $this->user->getUsernameValue();
    }
}

class User
{
    // ...

    public function getUsernameValue()
    {
        return $this->username->getValue();
    }
}
~~~~~~~~

However, if you're going to do this for more that 2 or 3 values the interface
is going to start to get pretty bloated. Another way might be to add a method
to the `Recipe` class to return all it's values as an array or *Data Transfer
Object*. There are other ways you could do this but for this project let's use
a combination of these 2 methods. If only 1 or 2 getters are required we'll
consider using them, otherwise well using a *read* method to return a DTO (I
prefer objects to arrays because the content is defined and it can be immutable
- even though it's extra code. However, using an array or object with public
properties might be appropriate for your project).

### Exposing Recipe Values

With this in mind, let's expose the contents of the `Recipe` class via a DTO.
We do this by creating 2 DTO classes, one for `Recipe` and one for `User`:

<<[src/CocktailRater/Domain/RecipeDetails.php](examples/chapter-06/law-of-demeter/src/CocktailRater/Domain/RecipeDetails.php)

<<[src/CocktailRater/Domain/UserDetails.php](examples/chapter-06/law-of-demeter/src/CocktailRater/Domain/UserDetails.php)

And add the following method to `User` and `Recipe`:

{title="CocktailRater/Domain/Recipe.php", lang="php"}
~~~~~~~~
    /** @return RecipeDetails */
    public function getDetails()
    {
        return new RecipeDetails(
            $this->name,
            $this->user->getDetails(),
            $this->rating->getValue(),
            $this->method,
            array_map(
                function (MeasuredIngredient $ingredient) {
                    return [
                        'name'   => $ingredient->getIngredient()->getName(),
                        'amount' => $ingredient->getAmount()->getValue(),
                        'unit'   => $ingredient->getAmount()
                                               ->getUnit()
                                               ->getValue()
                    ];
                },
                $this->measuredIngredients
            )
        );
    }
~~~~~~~~

{title="CocktailRater/Domain/User.php", lang="php"}
~~~~~~~~
    /** @return UserDetails */
    public function getDetails()
    {
        return new UserDetails($this->username->getValue());
    }
~~~~~~~~

Then we can update our query handlers to use these like so:

{title="CocktailRater/Application/Visitor/ListRecipesHandler.php", lang="php"}
~~~~~~~~
    /** @return ListRecipesResult */
    public function handle(ListRecipesQuery $query)
    {
        $result = new ListRecipesResult();

        foreach ($this->getAllRecipesSortedByRating() as $recipe) {
            // leanpub-start-insert
            $details = $recipe->getDetails();
            // leanpub-end-insert

            $result->addRecipe(
                $details->getName(),
                $details->getRating(),
                $details->getUsername()
            );
        }

        return $result;
    }
~~~~~~~~

{title="CocktailRater/Application/Visitor/ViewRecipeHandler.php", lang="php"}
~~~~~~~~
    /**
     * @return ViewRecipeResult
     *
     * @throws InvalidIdException
     */
    public function handle(ViewRecipeQuery $query)
    {
        $recipe = $this->findRecipe($query);
        // leanpub-start-insert
        $details = $recipe->getDetails();
        // leanpub-end-insert

        return new ViewRecipeResult(
            // leanpub-start-insert
            $details->getName(),
            $details->getUsername(),
            $details->getRating(),
            $details->getMethod(),
            $details->getMeasuredIngredients()
            // leanpub-end-insert
        );
    }
~~~~~~~~

At this point we can also remove `getUsername` from the `User` class and
`getName`, `getRating`, `getUser`, `getMethod` and `getMeasuredIngredients`
from the `Recipe` class.

Already this is looking a whole lot neater but we're still violating the *law
of demeter* at 2 levels in the *handlers*. Firstly, we're calling `getDetails`
on a `Recipe` which is not actually an *immediate friend* of the handler (since
is is fetched from a repository). Secondly, we're calling the *get* methods on
the details returned from `$recipe`. Considering, this is happening just at the
application layer in our handler classes I don't really think this is the
biggest crime and could be left as it is. That said, let's still try and tidy
it up completely.

First up let's try and get rid of all the calls to the *getters* on the details
objects. We can do this by simply handing in the details DTO to the result
class constructor, the problem with this is that is adds a dependency on the
*domain model* from anywhere that a result object is used (since the result
object knows about the details object in the domain). When using a language
like Java, C++ or C# this becomes something that really needs to be considered
as separate packages need to be able to be compiled independently, however,
with PHP doesn't work like that (maybe one day it will). Even so, it's probably
still good practice to work this way and since we don't want other layers
talking to the application to create *result* objects let's make the *results*
into *interfaces* and have real result DTOs which can know about the *details*
DTO. This way the dependency from outside is on the interface and therefore
it's decoupled form the *domain*.

Now we have this:

<<[src/CocktailRater/Application/Visitor/Query/ListRecipesResult.php](examples/chapter-06/law-of-demeter/src/CocktailRater/Application/Visitor/Query/ListRecipesResult.php)

<<[src/CocktailRater/Application/Visitor/Query/ViewRecipeResult.php](examples/chapter-06/law-of-demeter/src/CocktailRater/Application/Visitor/Query/ViewRecipeResult.php)

<<[src/CocktailRater/Application/Visitor/Query/ListRecipesResultData.php](examples/chapter-06/law-of-demeter/src/CocktailRater/Application/Visitor/Query/ListRecipesResultData.php)

<<[src/CocktailRater/Application/Visitor/Query/ViewRecipeResultData.php](examples/chapter-06/law-of-demeter/src/CocktailRater/Application/Visitor/Query/ViewRecipeResultData.php)

{title="CocktailRater/Application/Visitor/ListRecipesHandler.php", lang="php"}
~~~~~~~~
    /** @return ListRecipesResult */
    public function handle(ListRecipesQuery $query)
    {
        $result = new ListRecipesResultData();

        foreach ($this->getAllRecipesSortedByRating() as $recipe) {
            // leanpub-start-insert
            $result->addRecipe($recipe->getDetails());
            // leanpub-end-insert
        }

        return $result;
    }
~~~~~~~~

{title="CocktailRater/Application/Visitor/ViewRecipeHandler.php", lang="php"}
~~~~~~~~
    /**
     * @return ViewRecipeResult
     *
     * @throws InvalidIdException
     */
    public function handle(ViewRecipeQuery $query)
    {
        // leanpub-start-insert
        return new ViewRecipeResultData(
            $this->findRecipe($query)->getDetails()
        );
        // leanpub-end-insert
    }
~~~~~~~~

That's almost it now, the handlers are much neater but we've still not quite
conformed to the *Law of Demeter*. ...

### Is this Taking it too far?

## The Ingredients Collection

## Forgotten Types

## DRY - Don't Repeat Yourself

DRY is a simple software principle which I've not mentioned yet and the name
pretty much sums it up. Applying DRY simply means if you find yourself typing
the same piece of code more than once, then extract it out into a
function, method, class or anything else which may be appropriate.

I've already applied this principle in some places, for example the
`getResultField` method in the `FeatureContext`. However, let's find another
place to apply it.

We've definitely got some repetition in some of the exception
class, take a look at these:

todo ... exception code.

To tidy this up let's use one of PHP's newer features, *traits*:

I> ### Traits
I>
I> PHP recently introduced `traits`. These are a way to include common bits
I> of code into multiple classes, almost in a copy & paste style. Traits in
I> PHP should be used to remove the repetition of small bit of code rather
I> than performing complex tasks, they should be extracted to dedicated
I> classes.
I>
I> You define the *methods* and *properties* in your `trait`, you can then use
I> those methods and properties in any class by including `use TraitName;` in
I> the body of the class.

todo ... tidy exceptions code.

D> ## Exception Messages
D>
D> Since we've put all this effort into creating nice exception message let's
D> quickly talk about them. Exception messages should not be designed to
D> display to the users of the application, they should be caught before they
D> get to the UI, logged, then a user friendly message displayed on screen.
D> The exception messages are for the developers, they are logged so problems
D> and bugs can be tracked down. Therfore, make your exception messages contain
D> as much context as necessary to understand the context.
D>
D> ### Example
D>
D> A *user* is logged in and tries to view their *recipe* but it's not found. A
D> reasonable message to display to the user might be:
D>
D> *"A recipe with ID '123' was not found."*
D>
D> But is this a good exception message? Not really as there's some missing
D> context here, they user know's who they are but to someone reading that
D> message in a log it is unclear. A better message might say:
D>
D> *"A recipe with ID '123' could not be found for user with ID '456'."*
D>
D> This is much more helpful.

Things:
* REMOVE ID FROM ACCEPTANCE TEST
* DRY and exception traits
* Problems in Feature Context
* Builder pattern
* Too many getters
* LoD and possible solutions - ISP/Extracted Object/Presenter


## Some Thoughts

Lots of test refactoring.
