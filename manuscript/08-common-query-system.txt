# Common Query System

In the last 2 chapters we started to build our application. In this chapter
we're going to start analysing the 2 queries we have built so far to try and
create a common way to use them. In a dynamically typed language, this is very
straight forward, whereas, in a statically typed language you have to use
certain techniques to make this possible. Since PHP is a dynamically typed
language which we are mostly using in a statically typed way, this chapter will
explore the range of possibilities available and weigh up the pros and cons to
try and find an appropriate solution. While the outcome will result in some
updates to our application, the chapter will serve more as an investigation
into the possible routes to solving this in PHP. For this reason, I suggest you
read this chapter in its entirety before trying out any of the examples.

## The Problem

First up, let's look at how we use our 2 queries:

{title="List Recipes Query"}
~~~~~~~~
<?php

$query = new ListRecipesQuery();

$handler = new ListRecipesHandler($recipeRepository);

$result = $handler->handle($query);

// do stuff with $result
~~~~~~~~

{title="View Recipe Query"}
~~~~~~~~
<?php

$query = new ViewRecipesQuery(12);

$handler = new ViewRecipeHandler($recipeRepository);

$result = $handler->handle($query);

// do stuff with $result
~~~~~~~~

It's very clear here that the process is the same for each query. Therefore,
there should some way to remove the ceremony of creating a query, creating the
appropriate handler and then invoking the handler.

## Creating the Handler

Since we've chosen a sensible convention for the naming of the *Query*,
*Handler* and *Result* objects. Let's try using PHP's ability to create classes
by name, to remove the need to create the correct handler. To do this, let's
create a *query handler* class, which will handle all our queries by letting it
create the require handler.

<<[src/Application/QueryHandler.php](examples/chapter-08/01-query-handler/src/Application/QueryHandler.php)

W> ### Exception Classes
W>
W> For brevity, I'm not including the source of the exception classes here.
W> There's nothing really interesting in them, but, if you want to see them you
W> can look in the included source code for this chapter.

T> ### QueryHandlerSpec
T>
T> The spec file for the QueryHandler class is somewhat interesting. It contains
T> some *not so idiomatic PHPSpec tests*. The techniques applied in this spec
T> there should not be overused, however, sometimes these approaches are
T> useful. Therefore, it's worth studying that file in the include source code
T> for this chapter.

After creating this QueryHandler class, we can also make the following
modifications to Behat's FeatureContext class:

{title="features/bootstrap/FeatureContext.php"}
~~~~~~~~
<?php

// ...

// leanpub-start-delete
use CocktailRater\Application\Query\ListRecipesHandler;
use CocktailRater\Application\Query\ViewRecipeHandler;
// leanpub-end-delete
// leanpub-start-insert
use CocktailRater\Application\QueryHandler;
// leanpub-end-insert

// ...

class FeatureContext implements SnippetAcceptingContext
{
    // ...

    /**
     * @When I request a list of recipes
     */
    public function iRequestAListOfRecipes()
    {
        $this->storeRecipes();

        // leanpub-start-insert
        $this->handleQuery(new ListRecipesQuery());
        // leanpub-end-insert
    }

    // ...

    /**
     * @When I request to view recipe for :name
     */
    public function iRequestToViewRecipeFor($name)
    {
        $this->storeRecipes();

        // leanpub-start-insert
        $this->handleQuery(new ViewRecipeQuery($this->recipes[$name]['id']));
        // leanpub-end-insert
    }

    // ...

    // leanpub-start-insert
    private function handleQuery($query)
    {
        $handler = new QueryHandler($this->recipeRepository);

        $this->result = $handler->handle($query);
    }
    // leanpub-end-insert
}
~~~~~~~~

At this point, the Behat acceptance tests should still pass. And, from looking
at the FeatureContext and new QueryHandler, you can see we've started to pull
together the common aspects of the our 2 queries.

Now, taking another look at the QueryHandler, you can see that quite a lot of
the code is actually error checking. It's checks that a Query *appears* to be
a Query, and a Handler implements a *handle* method. It should be pretty
obvious that type hinting should be a better fit here. Let's have a go at
doing this.

## The Query Handler Interface

Since we've recognise that handlers are used in a common way, let's start off
by defining a Handler interface:

<<[src/Application/QueryHandler.php](examples/chapter-08/02-handler-interface/src/Application/Handler.php)

This simply defines the `handle()` method for a handler. Since each handler
requires a different query type we can't define that type here and will have to
do some type checking ourselves in the handlers.

Now we can also make this little update to the QueryHandler to check the
type rather than the handler's class name:

{title="src/Application/QueryHandler.php"}
~~~~~~~~
<?php

namespace CocktailRater\Application;

// ...

class QueryHandler
{
    // ...

    private function assertQueryHandlerExists($query)
    {
        $handlerName = $this->getHandlerName($query);

        if (!class_exists($handlerName)) {
            throw NoMatchingHandlerException::notFound(
                get_class($query),
                $handlerName
            );
        }

        // leanpub-start-insert
        if (!is_subclass_of($handlerName, Handler::class)) {
            throw NotAHandlerException::missingHandleMethod($handlerName);
        }
        // leanpub-end-insert
    }
}
~~~~~~~~

So far so good, but now let's look at how it effects the handler classes:

{title="src/Application/Query/ListRecipesHandler.php"}
~~~~~~~~
<?php

namespace CocktailRater\Application\Query;

// leanpub-start-insert
use Assert\Assertion;
use CocktailRater\Application\Handler;
// leanpub-end-insert
// ...

// leanpub-start-insert
final class ListRecipesHandler implements Handler
// leanpub-end-insert
{
    // ...

    // leanpub-start-insert
    /**
     * @param ListRecipesQuery
     *
     * @return ListRecipesResult
     */
    public function handle($query)
    {
        Assertion::isInstanceOf($query, ListRecipesQuery::class);
        // leanpub-end-insert

        return new ListRecipesResultData(
            array_map(function (Recipe $recipe) {
                return $recipe->getDetails();
            },
            $this->getAllRecipesSortedByRating())
        );
    }

    // ...
}
~~~~~~~~

{title="src/Application/Query/ViewRecipeHandler.php"}
~~~~~~~~
<?php

namespace CocktailRater\Application\Query;

// leanpub-start-insert
use Assert\Assertion;
// leanpub-end-insert
use CocktailRater\Application\Exception\InvalidIdException;
// leanpub-start-insert
use CocktailRater\Application\Handler;
// leanpub-end-insert
// ...

// leanpub-start-insert
final class ViewRecipeHandler implements Handler
// leanpub-end-insert
{
    // ...

    // leanpub-start-insert
    /**
     * @param ViewRecipeQuery $query
     *
     * @return ViewRecipeResult
     *
     * @throws InvalidIdException
     */
    public function handle($query)
    {
        Assertion::isInstanceOf($query, ViewRecipeQuery::class);
        // leanpub-end-insert

        return new ViewRecipeResultData(
            $this->findRecipe($query)->getDetails()
        );
    }

    // ...
}
~~~~~~~~

In both of the handlers we now added manual type checking for the `$query`
parameter. This works and theoretically there's nothing really wrong with it.
In pure dynamically typed languages this would be the norm. In strong
statically typed languages you'd have to go a bit further to get this approach
to work (involving a base type and type casting). There is, however, a more
elegant solution which gets all the type information into the class definition
by passing in the query as a constructor parameter instead. Let's give it a
try.

### Using Constructor Parameters

This time let's work backwards; I'll start by showing the handlers and then
adjust the other parts as required.
