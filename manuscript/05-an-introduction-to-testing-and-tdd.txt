# An Introduction to Testing and TDD

In this chapter I'm going to introduce some testing tools which we will be
using, as well as give a brief introduction to TDD. This is an optional chapter
so if you're already familiar with these tools and TDD then feel free to skip
it. However, if you are new to TDD, or have not been doing it for long, then
this chapter is definitely worth reading.

Like most of the things I've covered so far, this chapter is just here to serve
as a brief introduction. It aims to give you what you will need to work through
the rest of this book. As always, I recommend you research further in to
everything covered here - there are many wonderful resources available.

## Types of Test

The 2 main types of test which we will be using during the process of building
our application are: *acceptance tests* and *unit tests*.

### Acceptance Tests {#acceptance-tests}

*Acceptance tests* are high level tests which confirm to the developer **and**
the stakeholder, that the required features have been implemented and are
working properly. Since these tests are about producing the features that the
stakeholder requests, they are ideally produced with the stakeholder's presence and
input and in a form which they can understand.

A typical example might be to write something down like this:

> #### Listing customers when there are none will return an empty list
>
> Given there are no customers
>
> When I ask to list customers
>
> Then I should get an empty list

These simple rules could then be converted easily into automated tests using
any assert based test framework, like so:

{title="xUnit style acceptance test example:", lang="php"}
~~~~~~~~
function test_that_listing_customers_when_there_are_none_will_return_an_empty_list()
{
    // Given there are no customers
    $customerRepository = new CustomerRepository();
    $customerRepository->clear();

    // When I ask to list customers
    $lister = new CustomerLister($customerRepository);
    $customers = $lister->listCustomers();

    // Then I should get an empty list
    $this->assertEquals([], $customers);
}
~~~~~~~~

This works. The comments are there to explain the test in terms the stakeholder
can understand, and the code checks the conditions are met. That said, it does
mix up the stakeholder's language with the programmer's, and it relies on the
comments being present and correct. Therefore, if you are working with the
stakeholder to produce acceptance tests, then there is a better tool for the job.
It's called *Cucumber*, and in PHP it's implemented by a tool called
[Behat](http://behat.org/).

*Cucumber* scripts are tests written in a language that the stakeholder can read
and write in also. Tests are grouped as *features*, which are a collection of
*scenarios*. These *scenarios* look very much like the original test rules we
started with:

{title="Behat acceptance test example", lang="cucumber"}
~~~~~~~~
Feature: List customers
    In order to view a list of customers on the system
    As an administrator
    I need to be able to see lists of the customers information

    Scenario: Listing customers when there are none will return an empty list
        Given there are no customers
        When I ask to list customers
        Then I should get an empty list
~~~~~~~~

The language used in the Behat tests can include any phrases that you want.
The meanings of these phases (called *snippets*) are then implemented in PHP in
classes know as *contexts*. Here's an example:

{title="Behat context example", lang="php"}
~~~~~~~~
<?php

use Behat\Behat\Tester\Exception\PendingException;
use Behat\Behat\Context\SnippetAcceptingContext;
use Behat\Gherkin\Node\PyStringNode;
use Behat\Gherkin\Node\TableNode;

/**
 * Behat context class.
 */
class FeatureContext implements SnippetAcceptingContext
{
    /**
     * @var CustomerRepository
     */
    private $customerRepository;

    /**
     * @var mixed
     */
    private $result;

    /**
     * Initializes context.
     *
     * Every scenario gets its own context object.
     * You can also pass arbitrary arguments to the context constructor through
     * behat.yml.
     */
    public function __construct()
    {
        $this->customerRepository = new CustomerRepository();
    }

    /**
     * @Given there are no customers
     */
    public function thereAreNoCustomers()
    {
        $this->customerRepository->clear();
    }

    /**
     * @When I ask to list customers
     */
    public function iAskToListCustomers()
    {
        $lister = new CustomerLister($this->customerRepository);
        $this->result = $lister->listCustomers();
    }

    /**
     * @Then I should get an empty list
     */
    public function iShouldGetAnEmptyList()
    {
        if ([] !== $this->result) {
            throw new Exception('Result was not an empty array.');
        }
    }
}
~~~~~~~~

The different *snippets* can then be reused in other *scenarios* and *features*.

In this book, I will be providing the *features* for each new bit of
functionality that we add. We'll then use Behat to run the tests.

### Unit Tests

*Unit tests* are for the development team's benefit. They are not written with
the stakeholder's help; in fact they may event not know they exist.  Instead,
they are created by the developer as the code is written, and they test little
bits of code as isolated *units*. A unit is a small piece of code which
performs a specific task. Often, we treat each class as a unit, but there are
situations where multiple classes, or a subsection of a single class, could be
considered a unit. Saying that, PHPSpec (the main tool we will be using for
unit testing) does enforce that each class is a *unit*. As a result, this will
be the way that we shall mostly be working.

When doing [TDD](#tdd), the tests are actually written **before** each new bit
of code is written. This process, when used properly, actually influences what
code is written. Sometimes producing surprisingly elegant solutions.

There are 2 main types of *unit testing* tools, these are: *xUnit* style tools
and *BDD* style tools.

#### xUnit Frameworks

*xUnit* test tools are call so because each language has at least one of these
tools available and they are generally named *SomethingUnit* (e.g. JUnit for
Java, CppUnit for C++). The origin of these names comes from *Smalltalk's*
*SUnit*, which was created by Kent Beck and was the first testing framework of
this kind. Of course, PHP has such a framework, and as expected it is called
*PHPUnit*. *PHPUnit* is probably PHP's most well used unit testing framework
and was created by Sebastian Bergmann.

*xUnit* frameworks are based on assertions. Each framework provides a set of
available assertion functions. These are used to check that the results our
code produces are what we expect. Some examples of the assertions functions
available in *PHPUnit* are:

{title="PHPUnit assertions example", lang="php"}
~~~~~~~~
$this->assertEquals(7, $subject->getValue());
$this->assertSame($expectedOwner, $subject->getOwner());
$this->assertFalse($subject->isBroken());
$this->assertTrue($subject->isWonderful());
$this->assertNull($subject->getNothing());
// ...
~~~~~~~~

I> A full list of *PHPUnit's* assertions can be found in [Appendix
I> A](https://phpunit.de/manual/current/en/appendixes.assertions.html) of the
I> manual.

While we will not be using PHPUnit as the main *unit testing* framework in this
book, we will be making use of it at some point for certain tests. We will
also make use if its assertion library in our *Behat Contexts* for simplicity.

#### BDD Frameworks

The second type of unit testing frameworks are [BDD](#bdd) *spec* frameworks.
These are used in a very similar way to *xUnit* frameworks, but the language
used in a bit different. Instead of *asserting* a test's expectations, they are
described using the word *should*. The idea is that the tests describe the
functionality of a unit, rather than just check it's functionality. I will be
using [PHPSpec](http://www.phpspec.net/) which is a great, but *highly
opinionated*, BDD unit testing tool for PHP.

Using PHPSpec, the assertions we looked at for PHPUnit would written like this
instead:

{title="PHPSpec tests example", lang="php"}
~~~~~~~~
$this->getValue()->shouldReturn(7);
$this->getOwner()->shouldReturn($expectedOwner);
$this->shouldNotBeBroken();
$this->shouldBeWonderful();
$this->getNothing()->shouldReturn(null);
~~~~~~~~

The first difference you should notice is that they simply read as better
sentences than the *PHPUnit* assertions.

There is a second difference though: assertions allow you to assert the values
of anything. Whereas, PHPSpec's _should\*_ methods only work on return values
from the unit being tested or on *test double* methods. This means that you are
much more limited in how you can test with *PHPSpec*, however, this is not
necessarily a bad thing: it forces you to write good code and I like this (it's
not for everyone though).

#### Red, Green, Refactor: The TDD Unit Testing Process

When doing [TDD](#tdd), there is a process that defines the order in which
things should be done. This order is known as **Red, Green, Refactor**:

Red

: Red means that when we run our test suite we see a failing test. This is the
first step in writing code: *write a failing test*. The test we write should be
next smallest step we can take in our implementation which will cause the test
suite to fail. Once the test is written, you must run the test suite and you
**must see it fail**.

Green

: The green step is making the failing test pass. In order to do this you only
write **the smallest amount of code needed to make the failing test pass**.
Then we run the test suite again and see that all tests pass.

Refactor

: The refactor step is the point at which the code can, and should, be
refactored. No functionality should be altered here, you simply tidy up the
code. After any refactorings have been made, you must run the test suite to
make sure you've not broken anything.

After the *Refactor* step you go back to the **Red** step and write the next 
failing test. This process is repeated until the solution is complete.

![The Red, Green, Refactor Cycle](images/04-red-green-refactor.png)

I will run though a demonstration of this process shortly in the [Unit Testing
With PHPSpec](#unit-testing-with-phpspec) section.

## The Double Feedback Loop

*Acceptance tests* and *unit tests* support the development process in a
*double feedback loop*. *Acceptance tests* come from the *stakeholder* in order of
priority. The *developers* then implement the features using *unit tests* with
the *red, green, refactor cycle*, until the *acceptance tests* pass.  At this
point, the feature can be delivered to the *stakeholder* and the next set of
*acceptance tests* will be produced.

![The Double Feedback Loop](images/04-double-feedback-loop.png)

## Given, When, Then

We've already seen the use of these 3 words earlier in the [Acceptance
Tests](#acceptance-tests) section. However, these 3 steps apply to all types
of tests. The *given* part sets up the preconditions, the *when* part performs
the action being tested, and the *then* part checks the result. Whenever you
are writing a test, it is a good idea to maintain clear grouping into these 3
stages.

We've seen this in Behat already. It's highlighted and enforce by the
*Cucumber* language. Now lets take a look an example in a *PHPUnit* and a
*PHPSpec* test:

{title="Given, When, Then example using PHPUnit", lang="php"}
~~~~~~~~
// Inside AgeCalcuatorTest
function test_calculate_the_age_of_a_customer()
{
    // Given there is a customer whose date of birth is 1982-03-15
    // And today is 2014-09-03
    $customer = new Customer('customer name', Date::fromDate('1982-03-15'));
    $today = Date::fromDate('2014-09-03');

    // When I calcuate the age of the customer
    $calculator = new AgeCalculator($today);
    $age = $calculator->calculateAge($customer);

    // Then the result should be 32
    $this->assertEquals(32, $age);
}
~~~~~~~~

{title="Given, When, Then example using PHPSpec", lang="php"}
~~~~~~~~
// Inside AgeCalcuatorSpec
function it_can_calculate_the_age_of_a_customer()
{
    // Given there is a customer whose date of birth is 1982-03-15
    // And today is 2014-09-03
    $customer = new Customer('customer name', Date::fromDate('1982-03-15'));
    $this->beConstructedWith(Date::fromDate('2014-09-03'));

    // When I calcuate the age of the customer
    $age = $calculator->calculateAge($customer);

    // Then the result should be 32
    $age->shouldBe(32);
}
~~~~~~~~

The comments are not actually necessary, and it's also fine to compound the
various expressions (particularly the *when* and *then*) but the point is not
to mix up the order of these stages. I like to use vertical whitespace to
separate the setting up of the preconditions, from the tests. A more condensed
version of the *PHPSpec* example would be:

{title="Condensed Given, When, Then example using PHPSpec", lang="php"}
~~~~~~~~
// Inside AgeCalcuatorSpec
function it_can_calculate_the_age_of_a_customer()
{
    $customer = new Customer('customer name', Date::fromDate('1982-03-15'));
    $this->beConstructedWith(Date::fromDate('2014-09-03'));

    $calculator->calculateAge($customer)->shouldReturn(32);
}
~~~~~~~~

I think that looks pretty neat and is very easy to read and understand what is
supposed to happen.

## Acceptance Testing with Behat

We've already seen *Behat* and what *Cucumber* tests look like. Now let's have
a go at setting up a project using them. To start off create a new folder for
the project and `cd` into it:

{lang="console"}
~~~~~~~~
$ mkdir behat-example
$ cd behat-example
~~~~~~~~

Next up, let's add Behat to the project. We've already seen how to set up the
`composer.json` file but there is a simpler way: instead, we can create the
`composer.json`, add Behat to it, and run `composer update`, all in one command
like so:

```console
$ composer require behat/behat:3.* --dev
```

Once it has finished, Behat will be installed in the project and the `behat`
command will be available to us. Next, we need to tell Behat to initialise the
project - to do this simply run:

{lang="console"}
~~~~~~~~
$ behat --init
~~~~~~~~

This command creates a directory called `features`. This is where we'll put the
tests. It also creates directory inside `features` called `bootstrap`, which
contains a file called `FeatureContext.php`. This is the default context, and
is where we can add our *snippets*.

Now let's add a feature by creating a file called
`features/list-books.feature`:

{title="features/list-books.feature", lang="cucumber"}
~~~~~~~~
Feature: List books
    In order to list books
    As a reader
    I must be able to view a list of all books stored on the system

    Scenario: Display an empty list
        Given there are no books
        When I list all books
        Then I should see an empty list
~~~~~~~~

Next, run Behat:

{lang="console"}
~~~~~~~~
$ behat
~~~~~~~~

This should produce the following output:

{lang="console"}
~~~~~~~~
Feature: List books
    In order to list books
    As a reader
    I must be able to view a list of all books stored on the system

  Scenario: Display an empty list   # features/list-books.feature:6
    Given there are no books
    When I list all books
    Then I should see an empty list

1 scenario (1 undefined)
3 steps (3 undefined)
0m0.03s (9.00Mb)

--- FeatureContext has missing steps. Define them with these snippets:

    /**
     * @Given there are no books
     */
    public function thereAreNoBooks()
    {
        throw new PendingException();
    }

    /**
     * @When I list all books
     */
    public function iListAllBooks()
    {
        throw new PendingException();
    }

    /**
     * @Then I should see an empty list
     */
    public function iShouldSeeAnEmptyList()
    {
        throw new PendingException();
    }
~~~~~~~~

This is Behat saying that it doesn't understand the *snippets* which we have
used in the test. It also gives some template code which can be copied and
pasted into our feature context to implement these *snippets*. We could do
that, but we can actually get Behat to do this for us by running:

{lang="console"}
~~~~~~~~
$ behat --append-snippets
~~~~~~~~

If you look in `features/bootstrap/FeatureContext.php` after this command has
run, you will see the template code has been added for the 3 new *snippets*. At
this point we can run Behat again:

{lang="console"}
~~~~~~~~
$ behat
~~~~~~~~

This time it informs us that the first *snippet* has no content and needs to be
implemented (the others have been skipped). Let's implement the first
*snippet*.

Update `features/bootstrap/FeatureContext.php` so that it looks like this:

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
<?php

use Behat\Behat\Tester\Exception\PendingException;
use Behat\Behat\Context\SnippetAcceptingContext;
use Behat\Gherkin\Node\PyStringNode;
use Behat\Gherkin\Node\TableNode;

// leanpub-start-insert
use BehatExample\BookList;
// leanpub-end-insert

/**
 * Behat context class.
 */
class FeatureContext implements SnippetAcceptingContext
{
    // leanpub-start-insert
    /**
     * @var BookList
     */
    private $bookList;
    // leanpub-end-insert

    /**
     * Initializes context.
     *
     * Every scenario gets its own context object.
     * You can also pass arbitrary arguments to the context constructor through
     * behat.yml.
     */
    public function __construct()
    {
        // leanpub-start-insert
        $this->bookList = new BookList();
        // leanpub-end-insert
    }

    /**
     * @Given there are no books
     */
    public function thereAreNoBooks()
    {
        // leanpub-start-insert
        $this->bookList->clear();
        // leanpub-end-insert
    }

    /**
     * @When I list all books
     */
    public function iListAllBooks()
    {
        throw new PendingException();
    }

    /**
     * @Then I should see an empty list
     */
    public function iShouldSeeAnEmptyList()
    {
        throw new PendingException();
    }
}
~~~~~~~~

You can try running Behat again, but it will fail since there is no
`BookList` class. To create this quickly set up the autoloader by updating the 
`composer.json` to look like this:

<<[composer.json](examples/chapter-05/behat-example/composer.json)

Next, create the directory for the source code and update Composer:

{lang="console"}
~~~~~~~~
$ mkdir -p src/BehatExample
$ composer update
~~~~~~~~

Then, create the `BookList` class:

{title="src/BehatExample/BookList.php", lang="php"}
~~~~~~~~
<?php

namespace BehatExample;

class BookList
{
    public function clear()
    {
    }
}
~~~~~~~~

Running Behat at this point, will show the first *snippet* passing and inform
that the second snippet needs to be implemented. Let's implement the last 2
*snippets* at once: update the `features/bootstrap/FeatureContext.php` to
contain the following:

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
<?php

use Behat\Behat\Tester\Exception\PendingException;
use Behat\Behat\Context\SnippetAcceptingContext;
use Behat\Gherkin\Node\PyStringNode;
use Behat\Gherkin\Node\TableNode;

use BehatExample\BookList;

/**
 * Behat context class.
 */
class FeatureContext implements SnippetAcceptingContext
{
    /**
     * @var BookList
     */
    private $bookList;

    // leanpub-start-insert
    /**
     * @var mixed
     */
    private $result;
    // leanpub-end-insert

    /**
     * Initializes context.
     *
     * Every scenario gets its own context object.
     * You can also pass arbitrary arguments to the context constructor through
     * behat.yml.
     */
    public function __construct()
    {
        $this->bookList = new BookList();
    }

    /**
     * @Given there are no books
     */
    public function thereAreNoBooks()
    {
        $this->bookList->clear();
    }

    /**
     * @When I list all books
     */
    public function iListAllBooks()
    {
        // leanpub-start-insert
        $this->result = $this->bookList->getBooks();
        // leanpub-end-insert
    }

    /**
     * @Then I should see an empty list
     */
    public function iShouldSeeAnEmptyList()
    {
        // leanpub-start-insert
        if ([] !== $this->result) {
            throw new Exception('Result was incorrect.');
        }
        // leanpub-end-insert
    }
}
~~~~~~~~

Again, we've not implemented `BookList::getBooks()` so let's do that too:

{title="src/BehatExample/BookList.php", lang="php"}
~~~~~~~~
<?php

namespace BehatExample;

class BookList
{
    public function clear()
    {
    }

    // leanpub-start-insert
    /** @return array */
    public function getBooks()
    {
        return [];
    }
    // leanpub-end-insert
}
~~~~~~~~

Run Behat and see the test pass:

{lang="console"}
~~~~~~~~
$ behat
Feature: List books
    In order to list books
    As a reader
    I must be able to view a list of all books stored on the system

  Scenario: Display an empty list
    Given there are no books
    When I list all books
    Then I should see an empty list

1 scenario (1 passed)
3 steps (3 passed)
0m0.01s (9.10Mb)
~~~~~~~~

Before we move on, let's quickly add another test to the feature by appending
the following to `features/list-books.feature`:

{title="features/list-books.feature", lang="cucumber"}
~~~~~~~~

    Scenario: Books are listed in alphabetical order
        Given there is a book called "Domain Driven Design" by "Eric Evans"
        And there is a book called "Refactoring" by "Martin Fowler"
        And there is a book called "Design Patterns" by "The Gang of Four"
        When I list all books
        Then I should see:
            | title                | author           |
            | Design Patterns      | The Gang of Four |
            | Domain Driven Design | Eric Evans       |
            | Refactoring          | Martin Fowler    |
~~~~~~~~

Again, if you run Behat it will say that there are new, unknown *snippets*. As
before, add these by running:

{lang="console"}
~~~~~~~~
$ behat --append-snippets
~~~~~~~~

Open up `features/bootstrap/FeatureContext.php` again, and update the 2 new
methods which have been added to the class, so that they look like this:

{title="features/bootstrap/FeatureContext.php", lang="php"}
~~~~~~~~
    /**
     * @Given there is a book called :title by :author
     */
    public function thereIsABookCalledBy($title, $author)
    {
        // leanpub-start-insert
        $this->bookList->add($title, $author);
        // leanpub-end-insert
    }

    /**
     * @Then I should see:
     */
    public function iShouldSee(TableNode $table)
    {
        // leanpub-start-insert
        if ($table->getHash() !== $this->result) {
            throw new Exception('Result was incorrect.');
        }
        // leanpub-end-insert
    }
~~~~~~~~

Finally, update `BehatExample\BookList` to contain a working implementation:

<<[src/BehatExample/BookList.php](examples/chapter-05/behat-example/src/BehatExample/BookList.php)

Then run Behat to see the tests pass:

{lang="console"}
~~~~~~~~
$ behat
Feature: List books
    In order to list books
    As a reader
    I must be able to view a list of all books stored on the system

  Scenario: Display an empty list
    Given there are no books
    When I list all books
    Then I should see an empty list

  Scenario: Books are listed in alphabetical order
    Given there is a book called "Domain Driven Design" by "Eric Evans" 
    And there is a book called "Refactoring" by "Martin Fowler"
    And there is a book called "Design Patterns" by "The Gang of Four" 
    When I list all books                                               
    Then I should see:                                                  
      | title                | author           |
      | Design Patterns      | The Gang of Four |
      | Domain Driven Design | Eric Evans       |
      | Refactoring          | Martin Fowler    |

2 scenarios (2 passed)
8 steps (8 passed)
0m0.02s (9.15Mb)
~~~~~~~~

## Mink

AUTHOR NOTE: Coming soon...

### The Mink Context

AUTHOR NOTE: Coming soon...

### Which Language to use in Interface Tests

AUTHOR NOTE: Coming soon...

## Unit Testing with PHPSpec {#unit-testing-with-phpspec}

Now let's take a look at *unit testing*. We'll use *PHPSpec* for this. As we
work through building the application in the next section of this book, I'll be
showing the process of *acceptance testing*. However, I will not be showing the
process of *unit testing* in the examples (except in certain circumstances
where there is something to learn from it). The reason for this is, that it
would be a long winded, pointless and excessive process to document, and it
would detract from the topic of this book. That said, all the example code will
have been written using the full TDD process, and you should do the same. This
also means, that all the example code for this book will contain complete unit
tests which you can study for yourself.

Since we're not going to be highlighting the unit testing process when building
the application, we'll go through an example now to get familiar with the
process.

### Example

For our TDD example we'll create an algorithm which finds the greatest common
divisor of 2 numbers.

#### Setup

Let's start by creating a new project:

{lang="console"}
~~~~~~~~
$ mkdir phpspec-example
$ cd phpspec-example
~~~~~~~~

And configure Composer for the project:

<<[composer.json](examples/chapter-05/phpspec-example/composer.json)

{lang="console"}
~~~~~~~~
$ composer install
~~~~~~~~

Now we can start the TDD Cycle:

First of all, we'll tell PHPSpec to create a new Spec file. To do this run:

{lang="console"}
~~~~~~~~
$ phpspec desc PhpspecExample\\GreatestCommonDivisorFinder
~~~~~~~~

This will create a test file called
`spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php`. To run it use:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty
~~~~~~~~

PHPSpec will say it can't find the `PhpspecExample\GreatestCommonDivisorFinder`
class and offer to create it, say **Yes** and run will create it and run the
tests again. This time the test should pass.

I> ## Output Formatting
I>
I> The `--format=pretty` option is not necessary. I have added it because it
I> produces nice output which I can paste into this book.
I>
I> There are other formats available, these are: **progress** (the default),
I> **html**, **pretty**, **junit** and **dot**.

At this point 2 files have been created for us. The test:

{title="spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php", lang="php"}
~~~~~~~~
<?php

namespace spec\PhpspecExample;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class GreatestCommonDivisorFinderSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this->shouldHaveType('PhpspecExample\GreatestCommonDivisorFinder');
    }
}
~~~~~~~~

And the class we are going to implement:

{title="src/PhpspecExample/GreatestCommonDivisorFinder.php", lang="php"}
~~~~~~~~
<?php

namespace PhpspecExample;

class GreatestCommonDivisorFinder
{
}
~~~~~~~~

The `it_is_initializable` test has served it's purpose now so you can remove
that from the test.

#### Red

Now we need to think what the simplest condition we can test is, which will
make progress towards the final goal.

Let's start with the condition that when both numbers are the same, then that
number is the greatest common divisor.

Add the following test to the spec file:

{title="spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php", lang="php"}
~~~~~~~~
    function it_returns_the_number_if_both_values_are_that_number()
    {
        $this->findGreatestDivisor(5, 5)->shouldReturn(5);
    }
~~~~~~~~

Now we have to see this fail, so run:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty
~~~~~~~~

Again PHPSpec says that the `findGreatestDivisor` method does not exist and
offers to create it. Say **yes**, this will add the empty method to
`PhpspecExample\GreatestCommonDivisorFinder` and run it again. At this point
you should see some red:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  x returns the number if both values are that number
        expected [integer:5], but got null.

----  failed examples

        PhpspecExample/GreatestCommonDivisorFinder
  10  x returns the number if both values are that number
        expected [integer:5], but got null.


1 specs
1 examples (1 failed)
11ms
~~~~~~~~

This tells us that the test was expecting the value `5` to be returned, but
`null` was returned instead. Time to make make this test go green...

#### Green

Remember that in the green stage, we must only add the smallest amount of code
to make the test pass. In this case all we need to do is return the value `5`.
Update the `PhpspecExample\GreatestCommonDivisorFinder::findGreatestDivisor()`
method and re-run the tests:

{title="src/PhpspecExample/GreatestCommonDivisorFinder.php", lang="php"}
~~~~~~~~
    public function findGreatestDivisor($a, $b)
    {
        return 5;
    }
~~~~~~~~

This time we see the green result:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number


1 specs
1 examples (1 passed)
9ms
~~~~~~~~

#### Refactor

This is the point when we do our refactoring. However, right now there's not
much to refactor, so let's move straight on to the next failing test.

#### Red

For this next test, let's check that when the first number is a divisor of the
second number, then the first number should be returned. To do this add the
following test:

{title="spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php", lang="php"}
~~~~~~~~
    function it_returns_the_first_number_if_it_is_a_divisor_of_the_second()
    {
        $this->findGreatestDivisor(3, 9)->shouldReturn(3);
    }
~~~~~~~~

Now run PHPSpec to see red:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

     PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  x returns the first number if it is a divisor of the second
        expected [integer:3], but got [integer:5].

----  failed examples

        PhpspecExample/GreatestCommonDivisorFinder
  15  x returns the first number if it is a divisor of the second
        expected [integer:3], but got [integer:5].


1 specs
2 examples (1 passed, 1 failed)
12ms
~~~~~~~~

The first test continues to pass, but the second one does not since our
implementation currently only returns the integer `5`.

#### Green

Again, using the smallest change possible, we can easily change this to green
by just returning the first number:

{title="src/PhpspecExample/GreatestCommonDivisorFinder.php", lang="php"}
~~~~~~~~
    public function findGreatestDivisor($a, $b)
    {
        return $a;
    }
~~~~~~~~

Now when running PHPSpec we see that both tests are successfully passing:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  ✓ returns the first number if it is a divisor of the second


1 specs
2 examples (2 passed)
11ms
~~~~~~~~

#### Refactor

There's still nothing to refactor yet. So on to the next failing test...

#### Red

Let's now try the previous test the other way around: when the second number is
a divisor of the first, the second number should be returned.

{title="spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php", lang="php"}
~~~~~~~~
    function it_returns_the_second_number_if_it_is_a_divisor_of_the_first()
    {
        $this->findGreatestDivisor(9, 3)->shouldReturn(3);
    }
~~~~~~~~

Run PHPSpec again (**you have to see it fail!**):

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  ✓ returns the first number if it is a divisor of the second
  20  x returns the second number if it is a divisor of the first
        expected [integer:3], but got [integer:9].

----  failed examples

        PhpspecExample/GreatestCommonDivisorFinder
  20  x returns the second number if it is a divisor of the first
        expected [integer:3], but got [integer:9].


1 specs
3 examples (2 passed, 1 failed)
13ms
~~~~~~~~

#### Green

To make this one pass we can simply return the smaller of the two numbers:

{title="src/PhpspecExample/GreatestCommonDivisorFinder.php", lang="php"}
~~~~~~~~
    public function findGreatestDivisor($a, $b)
    {
        return min($a, $b);
    }
~~~~~~~~

Yet again, we run the tests and see the successful results:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  ✓ returns the first number if it is a divisor of the second
  20  ✓ returns the second number if it is a divisor of the first


1 specs
3 examples (3 passed)
10ms
~~~~~~~~

#### Refactor

Still nothing to refactor so let's move on...

#### Red

How about if there's no common divisor other than then number 1? Let's write a
test for that:

{title="spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php", lang="php"}
~~~~~~~~
    function it_returns_1_if_there_is_no_greater_divisor()
    {
        $this->findGreatestDivisor(3, 5)->shouldReturn(1);
    }
~~~~~~~~

As always, run the tests and see it fail:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  ✓ returns the first number if it is a divisor of the second
  20  ✓ returns the second number if it is a divisor of the first
  25  x returns 1 if there is no greater divisor
        expected [integer:1], but got [integer:3].

----  failed examples

        PhpspecExample/GreatestCommonDivisorFinder
  25  x returns 1 if there is no greater divisor
        expected [integer:1], but got [integer:3].


1 specs
4 examples (3 passed, 1 failed)
13ms
~~~~~~~~

#### Green

This one is a tiny bit more complicated. To solve it let's say that if the lower
of the 2 numbers is not a factor of one of the numbers, then return `1`:

{title="src/PhpspecExample/GreatestCommonDivisorFinder.php", lang="php"}
~~~~~~~~
    public function findGreatestDivisor($a, $b)
    {
        $divisor = min($a, $b);

        if ($a % $divisor !== 0 || $b % $divisor !== 0) {
            $divisor = 1;
        }

        return $divisor;
    }
~~~~~~~~

Run the tests:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  ✓ returns the first number if it is a divisor of the second
  20  ✓ returns the second number if it is a divisor of the first
  25  ✓ returns 1 if there is no greater divisor


1 specs
4 examples (4 passed)
11ms
~~~~~~~~

So far, so good!

#### Refactor

Finally, something to refactor! There is a duplication of the logic to check if
the `$divisor` variable is a factor of a variable. Let's extract it out with the
[extract method](http://refactoring.com/catalog/extractMethod.html) refactoring
like so:

{title="src/PhpspecExample/GreatestCommonDivisorFinder.php", lang="php"}
~~~~~~~~
<?php

namespace PhpspecExample;

class GreatestCommonDivisorFinder
{
    private $divisor;

    public function findGreatestDivisor($a, $b)
    {
        $this->divisor = min($a, $b);

        if (!$this->divisorIsFactorOf($a) || !$this->divisorIsFactorOf($b)) {
            $this->divisor = 1;
        }

        return $this->divisor;
    }

    private function divisorIsFactorOf($target)
    {
        return $target % $this->divisor === 0;
    }
}
~~~~~~~~

Now run the tests to make sure they still pass:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  ✓ returns the first number if it is a divisor of the second
  20  ✓ returns the second number if it is a divisor of the first
  25  ✓ returns 1 if there is no greater divisor


1 specs
4 examples (4 passed)
11ms
~~~~~~~~

#### Red

OK. Next let's try a divisor that is not `1`, or either of the numbers
themselves:

{title="spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php", lang="php"}
~~~~~~~~
    function it_returns_a_divisor_of_both_numbers()
    {
        $this->findGreatestDivisor(6, 9)->shouldReturn(3);
    }
~~~~~~~~

Watch the test fail:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  ✓ returns the first number if it is a divisor of the second
  20  ✓ returns the second number if it is a divisor of the first
  25  ✓ returns 1 if there is no greater divisor
  30  x returns a divisor of both numbers
        expected [integer:3], but got [integer:1].

----  failed examples

        PhpspecExample/GreatestCommonDivisorFinder
  30  x returns a divisor of both numbers
        expected [integer:3], but got [integer:1].


1 specs
5 examples (4 passed, 1 failed)
14ms
~~~~~~~~

#### Green

We actually only have to make a very small change here to make this pass: we
simply change the `if` to a `while`, and decrement the divisor in the loop:

{title="spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php", lang="php"}
~~~~~~~~
    public function findGreatestDivisor($a, $b)
    {
        $this->divisor = min($a, $b);

        // leanpub-insert-start
        while (!$this->divisorIsFactorOf($a) || !$this->divisorIsFactorOf($b)) {
            $this->divisor--;
        }
        // leanpub-insert-end

        return $this->divisor;
    }
~~~~~~~~

Run the tests:

{lang="console"}
~~~~~~~~
$ phpspec run --format=pretty

      PhpspecExample\GreatestCommonDivisorFinder

  10  ✓ returns the number if both values are that number
  15  ✓ returns the first number if it is a divisor of the second
  20  ✓ returns the second number if it is a divisor of the first
  25  ✓ returns 1 if there is no greater divisor
  30  ✓ returns a divisor of both numbers


1 specs
5 examples (5 passed)
11ms
~~~~~~~~

Everything has passed! And, if you study the code you should see we've
reached a final solution to *find the greatest common divisor or 2 numbers*.

If you really want to double check it, you could add this extra test, but it
will pass straight away:

{title="spec/PhpspecExample/GreatestCommonDivisorFinderSpec.php", lang="php"}
~~~~~~~~
    function it_returns_the_greatest_divisor_of_both_numbers()
    {
        $this->findGreatestDivisor(12, 18)->shouldReturn(6);
    }
~~~~~~~~

#### Refactor

Looking at the code that we've produced, I'd say it's pretty neat already, and
doesn't require any additional refactoring. Maybe we could just add some
*docblocks* for type information.

#### The Result

Here is this final result. A complete solution to our original problem,
achieved by TDD:

<<[src/PhpspecExample/GreatestCommonDivisorFinder.php](examples/chapter-05/phpspec-example/src/PhpspecExample/GreatestCommonDivisorFinder.php)

## Test Doubles {#test-doubles}

I've already mentioned *test doubles*, and how they can be used to help test
units of code in isolation by replacing the unit's dependencies. Now let's take
a look at how this is actually done.

### Types of Test Doubles

*Test doubles* take on different forms depending on how the are used. Each of
these different types are used to solve a different problem. Let's take a
look at the different types.

#### Dummy

A *dummy* is the simplest *test double*. It simply serves as a place holder for
a dependency. It's essentially an empty class which implements the dependency's
interface. *Dummies* are used when the unit being tested has a required
dependency, but the dependency is not needed for the functionality being
tested.

{title="Dummy test double example", lang="php"}
~~~~~~~~
/**
 * Method to be tested.
 *
 * @param number $a
 * @param number $b
 *
 * @return number
 */
public function addValues(Writer $writer, $a, $b)
{
    $writer->write("Adding $a and $b");

    return $a + $b;
}

/**
 * The test.
 *
 * Here we only want to test the addition takes place and don't care
 * about the writer. However, the writer is required, so we provide a dummy in
 * its place.
 */
function test_dummy()
{
    $writer = new DummyWriter();
    $examples = new Examples();

    $this->assertEquals(5, $examples->addValues($writer, 2, 3));
}

/**
 * The dummy writer.
 *
 * No functionality is requried, it just needs to implement the Writer
 * interface.
 */
final class DummyWriter implements \Writer
{
    public function write($string)
    {
    }
}
~~~~~~~~

#### Stub

A *stub* is the next simplest *test double*. It simply returns constant values
from the methods in the public interface. *Stubs* are used to isolate the unit
under test, from the complexity of its dependency, or for testing an
interface or abstract class which has no implementation available.

{title="Stub test double example", lang="php"}
~~~~~~~~
/**
 * The method being tested.
 *
 * @return int
 */
public function doubleInput(Reader $reader)
{
    return $reader->readInt() * 2;
}

/**
 * The test.
 *
 * We don't want to use a real Reader to check the logic, so we use a stub
 * which returns a constant value, which we can reliably check.
 */
function test_stub()
{
    $reader = new StubReader();
    $examples = new Examples();

    $this->assertEquals(14, $examples->doubleInput($reader));
}

/**
 * The stub reader.
 *
 * There is no logic in a stub, it simply returns constant values.
 */
final class StubReader implements Reader
{
    public function readInt($src = self::STDIN)
    {
        return 7;
    }
}
~~~~~~~~

#### Fake

A *fake* contains logic which emulates a simplified and reliable version of the
dependency. *Fakes* are used when the dependency is suitably complex, that a
stub is not powerful enough.

{title="Fake test double example", lang="php"}
~~~~~~~~
/**
 * The method being tested.
 *
 * Here Reader::readInt() is called multiple times with different parameters.
 */
public function addFromInputAndFile(Reader $reader, $filename)
{
    return $reader->readInt(Reader::STDIN) + $reader->readInt($filename);
}

/**
 * The test.
 *
 * We're using a fake as we want different values to be returned depending
 * on the parameters provided.
 */
function test_fake()
{
    $reader = new FakeReader();
    $examples = new Examples();

    $this->assertEquals(
        7,
        $examples->addFromInputAndFile($reader, 'file.txt')
    );
}

/**
 * The fake reader.
 *
 * Here we return a 2 if the reader is instructed to read from STDIN, otherwise
 * it returns 5.
 */
final class FakeReader implements Reader
{
    public function readInt($src = self::STDIN)
    {
        return $src == self::STDIN ? 2 : 5;
    }
}
~~~~~~~~

#### Mock

A *mock* is like a *fake*, but unlike a *fake* *mocks* are aware that they are
part of a test suite. Rather than being just a simplified implementation of
the dependency's interface, they contain testing related logic and code.

When crafting *test doubles* by hand the situation for creating a *mock* comes
up very rarely. However, as we'll see in a moment, *test doubles* can be
created automatically using *mocking frameworks*. In this case all test doubles
are technically *mocks*, regardless of the actual way they are being used. For
this reason, the term *mock* is often used interchangeably with *test double*.

#### Spy

A *spy* is a type of *mock* which records the actions which have been performed
on it. After executing the code under test, a spy can be asked if it was
interacted with as expected. *Spies* are used to verify a dependency has be
used in the correct way.

{title="Spy test double example", lang="php"}
~~~~~~~~
/**
 * Method being tested.
 *
 * @param number $a
 * @param number $b
 *
 * @return number
 */
public function addValues(Writer $writer, $a, $b)
{
    $writer->write("Adding $a and $b");

    return $a + $b;
}

/**
 * The test.
 *
 * This time, we want to make sure that the writer was instructed to write a
 * message.
 */
function test_spy()
{
    $writer = new SpyWriter();
    $examples = new Examples();

    $examples->addValues($writer, 2, 3);

    $this->assertTrue(
        $writer->hasWriteBeenCalledWith('Adding 2 and 3'),
        '$writer->write("Adding 2 and 3") should have been called'
    );
}

/**
 * The spy write test double.
 *
 * The spy records the message that the write function was called with.
 */
final class SpyWriter implements \Writer
{
    private $message;

    public function write($message)
    {
        $this->message = $message;
    }

    /**
     * @param string $message
     *
     * @return bool
     */
    public function hasWriteBeenCalledWith($message)
    {
        return $this->message == $message;
    }
}
~~~~~~~~

### Expectations

*Expectations* serve a similar purpose to *spies*, except rather than recording
what methods have been called so they can be checked later, the methods
required to be called are defined first. Not all mocking framework's provide
both *spies* and *expectations*, but generally they will support at least one
of these features.

The one thing which using *expectations* does, is mix up the *given, when,
then* order. For this reason, I prefer to use *spies* when possible.

### Mocking Frameworks

There are many mocking frameworks available for PHP. PHPUnit has one built in,
PhpSpec uses one called [Prophecy](https://github.com/phpspec/prophecy), and
there are others available too. The main reasons for using a different
framework are, either because it provides some extra features, or because
they produce tests which you think are easier to understand.

Some examples of other mocking frameworks are
[Mockery](https://github.com/padraic/mockery),
[Phake](http://phake.readthedocs.org/en/latest/) and Facebook's
[FBMock](https://github.com/facebook/FBMock).

Now, let's quickly take a look at the previous test double examples, this time
using PHPUnit's and PHPSpec's Prophecy framework's mocking facilities.

#### PHPUnit

PHPUnit's built in mocking facilities are quite verbose, and often considered 
to not be the easiest to read. It also doesn't support *spies*, so you have to
use *expectations*. For these reasons, alternative mocking frameworks are often
chosen when working with PHPUnit.

Here's the examples with PHPUnit:

<<[tests/MockExampleTest.php](examples/chapter-05/test-doubles/tests/MockExampleTest.php)

#### PHPSpec & Prophecy

Prophecy is very much a part of PHPSpec. By using PHPSpec, you are choosing
to use Prophecy also. That said, Prophecy doesn't have to be used with PHPSpec
and can be used with other test frameworks also.

PHPSpec makes mocking exceptionally simple. You don't need to call any special
methods to create a mock, rather you just provide a *typehinted* parameter to
the test method, and PHPSpec will create and inject the mock automatically.

Here's the same examples with PHPSpec:

<<[spec/ExamplesSpec.php](examples/chapter-05/test-doubles/spec/ExamplesSpec.php)

## Katas

In order to develop and hone your programming skills, the concept of *katas* has
become a popular way to practice them. A *kata* (like a martial arts kata) is a
sequence of steps which are performed repeatedly in order to drill and perfect
the skills and techniques which they contain.

Some popular katas are *Prime Factors*, *The Bowling Game*, *String Calculator*
and *Roman Numerals*. You can easily find the details and demonstrations of
these katas in many languages with a quick web search. That said Ciaran
McNulty has put up excellent videos of the [Prime
Factors](http://vimeo.com/74529780) and [Roman
Numerals](http://vimeo.com/88289877) katas using PHPSpec on Vimeo. I think
these are well worth a watch.
