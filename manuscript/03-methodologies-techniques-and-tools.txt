# Methodologies, Techniques and Tools

In this chapter I want to introduce the paradigms, methodologies and techniques
incorporated in this book. Like the previous chapter I don't want to go into
any real depth with any of these topics, rather I just want to give a primer on
the each subject which should provide enough to understand the content of this
book. As always I do encourage you dig deeper into each of the subjects
yourself and I will provide references of where to start looking when you want
to do this.

## Object Oriented Programming (OOP){#oop}

Sometimes I think there is a misconception that if you use classes in your code
then you are doing OOP. This is not the case, OOP is an approach to modelling
which involves grouping your business model down into objects, then grouping
the related data and behaviours (methods) in your code as classes, and then
defining how they interact with each other.

The OO style of programming can even be done in languages which have no
concepts of classes, also classes can be used ways which really don't represent
good OO code.

This is not a book on OO design but we will be using it extensively and I will
be explaining my choices for doing the things I do. As a result, coming in cold
to the subject you will probably get a good feel for OOP, but if this is the
case you should really go and learn more on the subject. If you do already have
some experience of OOP but you're not an expert then I hope you will really
have a lot to gain from this book.

Before moving on I just want to quickly cover a couple of OO topics.

### Encapsulation

Objects consist of *state* (its properties) and its *public interface* (all
public methods and properties). Generally there are rules as to what are the
valid values for any object's state. Encapsulation is making sure that that
state is private so that it can only be changed via the public interface's
methods.

The point I want to make here is you should design your public methods so that
there is no way that the object can be put into an invalid state.

Let's look at a couple of examples:

An object to represent an email address should not contain strings which could
not be valid email addresses. In this case it would make sense to throw an
exception if the email address provided does not look like a valid email
address:

{title="Well defined value object example", lang=php}
~~~~~~~~
<?php

class EmailAddress
{
    /** @var string */
    private $address;

    /** @param string $address */
    public function __construct($address)
    {
        if (strpos($address, '@') === false) {
            throw new InvalidArgumentException(
                'Email addresses must contain an @ symbol'
            );
        }

        $this->address = $address;
    }

    public function __toString()
    {
        return $this->address;
    }
}
~~~~~~~~

In the example above we chose the simple rule that *anything with an `@` symbol
in it could be an email address* (obviously in production code this needs to be
more well defined). If you study the code above you will find that there is no
way that you can create an instance of `EmailAddress` with an email address
which does not contain an `@` symbol. This is good design.

In another example consider implementing a collection of words which maintains
a count of how many words it contains. This collection class will have 2
properties; the list of words and the count. In order to add words to the
collection we must add the word to the list and increment the count. Firstly
let's do this with 2 seperate methods:

{title="Bad state consistency example", lang=php}
~~~~~~~~
<?php

class WordCollection
{
    /** @var string[] */
    private $words = [];

    /** @var int */
    private $count = 0;

    /** @param string $word */
    public function addWord($word)
    {
        $this->words[] = $word;
    }

    public function incrementCounter()
    {
        $this->count++;
    }

    /** @return string[] */
    public getWords()
    {
        return $this->words;
    }

    /** @return int */
    public getNumberOfWords()
    {
        return $this->count;
    }
}
~~~~~~~~

Now you can probably see what's wrong with that straight away but let me
explain for completeness. Take the following code:

{lang=php}
~~~~~~~~
<?php

$collection = new WordCollection();

$collection->addWord('hello');
$collection->incrementCounter();
~~~~~~~~

It looks OK and `$collection` is left in a valid state right? But is it always
in a valid state? Look again:

{lang=php}
~~~~~~~~
<?php

$collection = new WordCollection();

// words in list = 0
// counter = 0

$collection->addWord('hello');

// words in list = 1
// counter = 0
// Oh dear!

$collection->incrementCounter();

// words in list = 1
// counter = 1
~~~~~~~~

So there's a point in the middle where the state of the object is invalid, we
do fix it in the next line of code but what if a developer forgot to increment
the counter? It could lead to a nasty bug!

The solution is simple; design the class so it can never be put into an invalid
state:

{title="Good state consistency example", lang=php}
~~~~~~~~
<?php

class WordCollection
{
    /** @var string[] */
    private $words = [];

    /** @var int */
    private $count = 0;

    /** @param string $word */
    public function addWord($word)
    {
        $this->words[] = $word;

        // increment the counter when the word is added
        $this->count++;
    }

    /** @return string[] */
    public getWords()
    {
        return $this->words;
    }

    /** @return int */
    public getNumberOfWords()
    {
        return $this->count;
    }
}
~~~~~~~~

SORTED!

### Inheritance vs. Composition

Inheritance is a very useful and powerful tool in OOP but it is often misused,
the most common misuse of inheritance is using it to bring common functionality
into 2 unrelated classes.

An example could be: A bird and an aeroplane both fly so it might seem
reasonable to inherit both a `Bird` class and an `Aeroplane` class from a
`FlyingThing` superclass:

{title="Misused Inheritance", lang=php}
~~~~~~~~
<?php

abstract class FlyingThing
{
    public function startFlying()
    {
        // ...
    }

    // ...
}

class Bird extends FlyingThing
{
}

class Aeroplane extends FlyingThing
{
}
~~~~~~~~

There are a few reasons why this is a problem:

Firstly we only have single inheritance in PHP which means we can't extend from
more than one super class.  Birds can communicate with each other and
aeroplanes (well the pilots) can communicate with each other; if we wanted to
add a `CommunicatingThing` class then we couldn't inherit from it as well as
`FlyingThing` without creating a horrible `CommunicatingFlyingThing` class
instead.

Next up birds start flying by *flapping their wings* whereas an aeroplane is
propelled be its engines, so now we have 2 different types of `FlyingThing`.
The same goes for communicating; birds do it by *tweeting* and aeroplanes do it
by *radio*.

Finally, we've categorised birds and aeroplanes, which are 2 very different
things, together as *flying things* and *communicating things* which we've
had to make up. A much more sensible category for an aeroplane might be a
*vehical*, and for a bird maybe an *animal*.

So how to fix it? Well so far we've been talking about *is a*; *a bird **is a**
flying thing*. Inheritance is all about *is a*, but we also have *has a*. What
might be better is if we say *a bird **has a** flight system* or *an aeroplane
**has a** communication system*. When talking about **has a** we are talking
about composition so let's take a look at a better example of how to model
this:

{title="Using composition", lang=php}
~~~~~~~~
<?php

class FlightSystem
{
    public function startFlying()
    {
        // ...
    }

    // ...
}

class CommunicationSystem
{
    /** @param string $message */
    public function sendMessage($message)
    {
        // ...
    }

    // ...
}

class Bird
{
    /** @var FlightSystem */
    private $flightSystem;

    /** @var CommunicationSystem */
    private $communicationSystem;

    public function __construct()
    {
        $this->flightSystem = new FlightSystem();
        $this->communicationSystem = new CommunicationSystem();
    }

    public function startFlying()
    {
        $this->flightSystem->startFlying();
    }

    /** @param string $message */
    public function sendMessage($message)
    {
        $this->communicationSystem->setMessage($message);
    }
}


class Aeroplane
{
    /** @var FlightSystem */
    private $flightSystem;

    /** @var CommunicationSystem */
    private $communicationSystem;

    public function __construct()
    {
        $this->flightSystem = new FlightSystem();
        $this->communicationSystem = new CommunicationSystem();
    }

    public function startFlying()
    {
        $this->flightSystem->startFlying();
    }

    /** @param string $message */
    public function sendMessage($message)
    {
        $this->communicationSystem->setMessage($message);
    }
}
~~~~~~~~

What's more, once we start to realise that a bird's flight system is very
different from an aeroplane's then we can start have different flight systems
which can still but be instructed to start flying in the same way:

{title="Flexible flight systems", lang=php}
~~~~~~~~
interface FlightSystem
{
    public function startFlying();
}

class FlappingFlightSystem implements FlightSystem
{
    public function startFlying()
    {
        // ...
    }
}

class PropelledFlightSystem implements FlightSystem
{
    public function startFlying()
    {
        // ...
    }
}

class Bird
{
    // ...

    public function __construct()
    {
        $this->flightSystem = new FlappingFlightSystem();
        // ...
    }

    // ...
}

class Aeroplane
{
    // ...

    public function __construct()
    {
        $this->flightSystem = new FlappingFlightSystem();
        // ...
    }

    // ...
}
~~~~~~~~

The general rule here is, first of all determine if you are really modelling an
**is a** relationship or a **has a** relationship. Don't bend your model to fit
your code, rather make your code fit the model. When done properly you should
find you use inheritance pretty rarely.

## Design Patterns{#design-patterns}

Design Patterns are tried and tested solutions to various problems programmers
often face. There are several common design patterns which are very well known,
these are called things like the *visitor pattern* and the *strategy pattern*.

The de facto resource on this subject is the book titled *Design Patterns:
Elements of Reusable Object-Oriented Software* by the Gang of
Four[^the-gang-of-four]. Robert C. Martin says this book is *"probably the most
important book in software engineering written in the last 30 years"*. This
book is definitely a *must read* resource, however, you can now find all the
common design patterns listed and explained on
[Wikipedia](http://en.wikipedia.org/wiki/Software_design_pattern#Classification_and_list).

If you'd prefer to learn about Design Patterns from a PHP point of view then
Brandon Savage has written a book on the subject called
[Practical Design Patterns in PHP](http://practicaldesignpatternsinphp.com/).

I'm not going to go into any more details on design patterns here, I just
wanted you to know what they are for now. As we work though the book we will be
using various design patterns and as we do I shall point out which one we are
using and the reason for the choice to doing so.

[^gang-of-four]: Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides.

## Value Objects & Immutability

When we say something is immutable we mean that its value is fixed and can not
be changed. This means our classes are either *mutable* or *immutable*
depending on whether its public interface contains methods for changing its
internal state.

{title="Mutable email address class", lang=php}
~~~~~~~~
<?php

class MutableEmailAddress
{
    /** @var string */
    private $address;

    /** @var string */
    public function __construct($address)
    {
        $this->address = $address;
    }

    /** @var string */
    public function setAddress($address)
    {
        $this->address = $address;
    }

    public function __toString()
    {
        return $this->address;
    }
}
~~~~~~~~

{title="Immutable email address class", lang=php}
~~~~~~~~
<?php

class ImmutableEmailAddress
{
    /** @var string */
    private $address;

    /** @var string */
    public function __construct($address)
    {
        $this->address = $address;
    }

    public function __toString()
    {
        return $this->address;
    }
}
~~~~~~~~

These *immutable* classes we call *value objects*. This is because an instance
of that class represents a value and only that value; in the same way that we
can say 5 will always be 5, we can say that an `ImmutableEmailAddress` object
containing the email address `bill@microsoft.com` will always contain the email
address `bill@microsoft.com`, therefore this object represents the *value* of
that email address.

Value objects should be used to classify anything which is a specific thing.

### An Example

Instead of using a *float* for temperate use a `Temperature` value object, even
if it simplely contains a single *float* value. You might also want to store
the unit (Fahrenheit or Celsius) in the `Temperate` object, so a value object
can contain more than 1 scalar value. Also, the unit of temperature is a
specific thing in itself, so make that a value object too. Your value objects
should also only be able to be created with valid values, we don't want anyone
to be able to create a temperature of *"30 degrees **hotness**"*!

For completeness let's look a good implementation of what we've just discussed:

{title="Temperature; a good use of value objects", lang=php}
~~~~~~~~
<?php

class TemperatureUnit
{
    const CELSIUS    = 'c';
    const FAHRENHEIT = 'f';

    /** @var string */
    private $value;

    /** @param string $value */
    public function __construct($value)
    {
        $this->assertValueIsValid($value);

        $this->value = (float) $value;
    }

    /** @return string */
    public function getValue()
    {
        return $this->value;
    }

    private function assertValueIsValid($value)
    {
        if (!in_array($value, [self::CELSIUS, self::FAHRENHEIT])) {
            throw new InvalidArgumentException(
                'A temperature unit must be celsius or fahrenheit'
            );
        }
    }
}

class Temperature
{
    /** @var float */
    private $degrees;

    /** @var TemperatureUnit */
    private $unit;

    /** @param float $degrees */
    public function __construct($degrees, TemperatureUnit $unit)
    {
        $this->degrees = $degrees;
        $this->unit    = $unit;
    }

    /** @return float */
    public function getDegrees()
    {
        return $this->degrees;
    }

    /** @return TemperatureUnit */
    public function getUnit()
    {
        return $this->unit;
    }
}
~~~~~~~~

### The benefits

There are several benefits to using value objects:

#### Confidence

With a value object you know that it can't change unexpectedly, using our
`MutableEmailAddress` class from earlier consider the following code:

{title="Unexpected change of value", lang=php}
~~~~~~~~
<?php

function sendEmail(MutableEmailAddress $address)
{
    mail($address->getValue(), 'Hello', '...');
    $address->setValue('steve@apple.com');
}

function logEmailSent(MutableEmailAddress $address)
{
    echo "A message was sent to " . $address->getValue();
}

$address = new MutableEmailAddress('bill@microsoft.com');

sendEmail($address);    // send email to bill@microsoft.com
logEmailSent($address); // but logs "A message was sent to steve@apple.com"
~~~~~~~~

Looking at just the last 3 lines of code in the previous example, you would
expect the message would get sent to Bill and the log message would reflect
that, but it doesn't!

If we had used an `ImmutableEmailAddress` object instead then the
`$address->setValue('steve@apple.com');` line of code would not have been
allowed and would have caused an error. Therefore, we could be certain that our
last 3 lines of code would work as expected.

#### Consistency

If we create a function that takes a `Temperate` as an argument we can be
sure that the value we get is a valid `Temperate`. We don't need to write any
defensive code to check if that unit is valid or that degrees are specified as
a floating point value because all that was taken care of in the class
definitions of our value objects.

#### Documentation 

When you open a file and look at the code it's much easier to know the type of
a variable that was typehinted in the method argument list. This is a benefit
of typehints rather than value objects, however, by using value objects
abundantly you will have more types to typehint with.

## Dependency Injection (DI) & Inversion of Control (IoC)

Dependency Injection simply means that if you have a class that relies on
another class, rather than letting it create that other class internally, you
have to *inject* the dependency into it:

{title="No dependency injection example", lang=php}
~~~~~~~~
<?php

class Fooer
{
    public function doFoo()
    {
        // ...
    }
}

class Bar
{
    /** @var Fooer */
    private $fooer;

    public function __construct()
    {
        // Bar is in control of creating a Fooer.
        // As a result bar can only ever use a Fooer and never a subtype of Fooer.
        // This is known as "tight coupling"
        $this->fooer = new Fooer();
    }

    public function doBar()
    {
        $this->fooer->doFoo();
    }
}
~~~~~~~~

{title="Dependency injection example", lang=php}
~~~~~~~~
<?php

class Fooer
{
    public function doFoo()
    {
        // ...
    }
}

class Bar
{
    /** @var Fooer */
    private $fooer;

    /**
     * The Fooer must be injected into the instances of Bar.
     * It is also possible to inject and subtype of Fooer.
     */
    public function __construct(Fooer $fooer)
    {
        $this->fooer = $fooer
    }

    public function doBar()
    {
        $this->fooer->doFoo();
    }
}
~~~~~~~~

That's it, *Dependency Injection* is as easy as that, but why do it?

### Substituting Behaviour

Well first, up by injecting dependencies you're promoting the development of
flexible & reusable code, because not only can you inject the dependant type
but also any subtype. This makes it possible to extend your code without
actually modifying it by just changing what is injected in.

#### Example

Take this simple email address printer class:

{title="Email printer using dependency injection", lang=php}
~~~~~~~~
<?php

class EmailAddress
{
    /** @var string */
    private $address;

    /** @param string $address */
    public function __construct($address)
    {
        $this->address = (string) $address;
    }

    public function __toString()
    {
        return $this->address;
    }
}

interface EmailAddressRenderer
{
    /** @return string */
    public function render(EmailAddress $email);
}

class PlainTextRenderer implements EmailAddressRenderer
{
    public function render(EmailAddress $email)
    {
        return (string) $email;
    }
}

class EmailAddressPrinter
{
    /** @var EmailAddressRenderer */
    private $renderer;

    public function print(EmailAddress $address)
    {
        echo $this->renderer->render($address) . "\n";
    }
}
~~~~~~~~

To use our class we'd simply write something like this:

{title="Email printer example use", lang=php}
~~~~~~~~
<?php

$address = 'bill@microsoft.com';

$printer = new EmailAddressPrinter(new PlainTextRenderer());

$printer->print($address);
~~~~~~~~

This works great but then we are told we need to print out the email on a
webpage as a `mailto` link. Well because we've injected our
`EmailAddressRenderer` into the printer rather than letting the printer create
it, we can now inject anything which implements the `EmailAddressRenderer`
interface.

So let's add the HTMLRenderer:

{title="HTML email address renderer", lang=php}
~~~~~~~~
<?php

class HTMLRenderer implements EmailAddressRenderer
{
    public function render(EmailAddress $email)
    {
        return sprintf('<a href="mailto:%1$s">%1$s</a>', htmlentities($email);
    }
}
~~~~~~~~

Our code to make use of this would now look like this:

{title="HTML email printer example use", lang=php}
~~~~~~~~
<?php

$address = 'bill@microsoft.com';

$printer = new EmailAddressPrinter(new HTMLRenderer());

$printer->print($address);
~~~~~~~~

Simples! Notice how in order to change the way it behaves we have not altered
the original code in any way, instead we've simply extended it. Here we've
written our code in such a way that even though our printer uses a renderer, it
does not have control over how that renderer is created, it is just uses the
given renderer. This is known as *inversion of control*.

### Inversion Of Control

We've just seen an example of *inversion of control* so we know what it is, but
again what is it useful for?

* Firstly it creates extendible code
* Secondly it removes the need for your business code to know about
implementation details, such as how things are display or how messages are sent,
instead it allows those details to be plugged in. This is often done using the
[Adapter](http://en.wikipedia.org/wiki/Adapter_pattern) design pattern.
* Thirdly it allows your code to be easily tested as small, independent units. 
This is possible through the use of *test doubles*.

### Testing

As your codebase grows and you have more and more classes which each depend on
other classes, then in order to test anything you're going to have to create all
the dependencies of the class you are trying to test. Also, each of these
dependencies will have dependencies which will need to be created.

In this situation tests would get very complex and also fragile. If you were
to change anything, all your tests could break and it would take ages to get
them passing again.

By using *dependency injection*, *inversion of control* and *interfaces* you
get code which doesn't depend on fixed dependencies but rather on abstractions
(the interface) of the dependency. When your code is written like this your
dependencies are considered to be *loosely coupled*. 

When you code is *loosely coupled* you can create *test doubles*. These are
very simple & predictable versions of a class's dependencies, they can be
injected into the class instead of the real dependencies, allowing the class to
be tested in isolation. We'll look at this in more detail in the next chapter.

### Dependency Inject Containers (DIC) & Service Managers

These are tools which can manage the creation of objects and ensure that the
required dependencies get injected into them on creation. I'm not going to
talk about them here but will cover them in more detail when we need one.

All I will add now is that there are many DICs and Service Manager libraries
available should you ever decide you need one.

## The SOLID Principles{#the-solid-principles}

The SOLID Principles are the first 5 of the *Principles of Object Oriented
Design* which were compiled by Robert C. Martin.

The Principles are:

Single Responsibility Principle (SRP){#srp}

: A class should only have a single responsibility, don't make classes which do
a lot of different things.

Open Closed Principle (OCP){#ocp}

: You application should be open for extension but closed for modification. We
saw an example of this in action in the Dependency Injection section.

Liskov Substitution Principle (LSP){#lsp}

: This states objects can be replaced by subtypes of themselves and the program
should still work. What this means is that when you extend a class you should
make sure its public interface still behaves in the expected way, making it
possible to use your class in place of its parent anywhere in the program.

Interface Segregation Principle (ISP){#isp}

: This principle states that if something has a dependency but only uses a
subset of that dependency's public interface, then that subset should be made
into a separate interface and that interface should become the dependency.

Dependency Inversion Principle (DIP){#dip}

: Class's should not depend on other concrete classes, but rather on
abstractions (i.e. *abstract classes* and *interfaces*). Again we looked at
this earlier on in the email printer example.

More in-depth details can be found on
[Wikipedia](http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).

If you stick to these principles you we create fantastically modular,
extendible and testable applications.

## Functional Programming (FP)

--- todo minimal information to provide exceptions for CQS ---

### Pure Functions

### Method Objects

## Command Query Separation (CQS)

???

## Names

When writing code you have to decide on the names of many things. These include
*variables*, *classes* and *methods*. Choosing the names of these makes the
difference between code which is easily understandable and completely
indecipherable code.

When choosing names make them descriptive and so that the intent of your code
is clear. If your code is written well and the names are well chosen there
should be no need for any comments in your code. Robert C. Martin goes as far
as saying that choosing to adding a comment to your code is you accepting that
you have failed as a programmer to solve the problem. That does sound a bit
harsh but the under lying message is that your code should be self descriptive,
it's OK to use comments when something cannot be make clear in code but those
situations should be very, very rare!

A very simple rule for naming is *use nouns for variable and class names and
use verbs for method names*. It's not quite a black and white as that but it's
a very good place to start.

For some more interest talk on naming I thoroughly recommend having a read of
Mathias Verraes' [blog](http://verraes.net/).

### Make Method Names Describe Intent

When using creating methods make the intent and the method's purpose clear in
terms of the business rules.

Say for example, a customer moves house and needs to have their address updated
in the system. What might seem like an obvious approach would be to add a
`setAddress` method to the `Customer` class, this works be it's not as
informative as it could be, maybe a better method might be 'moveHouse'.

So far so good, but what if the customer's address was entered into the system
wrong and it just needs to be amended, does it make sense to call `moveHouse`
to update it? Of course not, so we add `amendPostalAddress` also:

{title="Good method names", lang=php}
~~~~~~~~
<?php

class Customer
{
    /** @var string */
    private $name;

    /** @var EmailAddress */
    private $emailAddress;

    /** @var PostalAddress */
    private $postalAddress;

    /** @param string $name */
    public function __construct($name, EmailAddress $emailAddress PostalAddress $postalAddress)
    {
        $this->name          = $name;
        $this->emailAddress  = $emailAddress;
        $this->postalAddress = $postalAddress;
    }

    public function moveHouse(PostalAddress $newAddress)
    {
        $this->postalAddress = $newAddress;
    }

    public function amendPostalAddress(PostalAddress $amendedAddress)
    {
        $this->postalAddress = $amendedAddress;
    }

    /** @return string */
    public function getName()
    {
        return $this->name;
    }

    /** @return EmailAddress */
    public function getEmailAddress()
    {
        return $this->emailAddress;
    }
}
~~~~~~~~

This is definitely mode descriptive but it's essentially 2 methods which do the
same thing, surely there's not point in that you might think? But there is, the
2 action are actually 2 separate tasks and by separating them we make it very
clear to anyone reading the code that there are 2 different events which result
in the change of a customer's address record.

This also makes it possible to easily extend the system. Say its all working
well but now we are told that emails should be sent to the customer when their
address changes; when they move house we need to send them a email
congratulating them on moving into a new home, when amending the address we
just want to notify them that their details have been updated.

Because we've separated the 2 actions this is very easy to add on, for this
example let's use the
[Decorator pattern](http://en.wikipedia.org/wiki/Decorator_pattern)[^why-decorator]:

{title="Emailing decorator", lang=php}
~~~~~~~~
<?php

class NotifyingCustomerDecorator extends Customer
{
    /** @var Customer */
    private $customer;

    /** @var Mailer */
    private $mailer;

    public function __construct(Customer $customer, Mailer $mailer)
    {
        $this->customer = $customer;
        $this->mailer   = $mailer;
    }

    public function moveHouse(PostalAddress $newAddress)
    {
        $this->customer->moveHouse($newAddress);

        $this->mailer->send(
            $this->customer,
            'Congratulations on moving into your new house!',
            '...'
        );
    }

    public function amendPostalAddress(PostalAddress $newAddress)
    {
        $this->customer->amendPostalAddress($newAddress);

        $this->mailer->send(
            $this->customer,
            'We have updated your details on our system',
            '...'
        );
    }

    /** @return string */
    public function getName()
    {
        return $this->customer->getName();
    }

    /** @return EmailAddress */
    public function getEmailAddress()
    {
        return $this->customer->getEmailAddress();
    }
}
~~~~~~~~

Pretty neat huh? Once again we have easily extended the system to add new
functionality without modifying the existing code, therefore, we are obeying
the [Open Closed Principle](#ocp).

[^why-decorator]: The reason I chose to use the *Decorator pattern* here
instead of just extending `Customer` was just to introduce the pattern. The
actual reason why you would choose to use this pattern would be if you wanted
to extend the `Customer` class when extensions which could be stacked on top of
each other.

## Refactoring{#refactoring}

## Code Callisthenics

## Automated Testing

## Test Driven Development (TDD){#tdd}

## Behaviour Driven Development (BDD){#bdd}

## Uncle Bob's Clean Code

## Domain Driven Design (DDD){#ddd}

## Agile

## User Stories
